[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Rust Espacial",
    "section": "",
    "text": "1 Prefacio",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Prefacio</span>"
    ]
  },
  {
    "objectID": "index.html#por-qué-rust",
    "href": "index.html#por-qué-rust",
    "title": "Rust Espacial",
    "section": "1.1 ¿Por qué Rust?",
    "text": "1.1 ¿Por qué Rust?\nRust es un lenguaje de programación moderno que combina alto rendimiento con una seguridad de memoria excepcional, lo que lo convierte en una herramienta poderosa para desarrolladores que trabajan en diversos dominios, desde sistemas de bajo nivel hasta aplicaciones web. A diferencia de lenguajes tradicionales, Rust ofrece una experiencia fluida, eliminando errores comunes como desbordamientos de memoria y condiciones de carrera. Es como conducir un automóvil con tecnología avanzada de asistencia: puedes concentrarte en alcanzar tus objetivos mientras Rust se asegura de mantenerte seguro en el camino, evitando los errores típicos del desarrollo y brindándote un control total.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Prefacio</span>"
    ]
  },
  {
    "objectID": "index.html#por-qué-rust-para-análisis-espacial",
    "href": "index.html#por-qué-rust-para-análisis-espacial",
    "title": "Rust Espacial",
    "section": "1.2 ¿Por qué Rust para análisis espacial?",
    "text": "1.2 ¿Por qué Rust para análisis espacial?\nRust destaca en la resolución de problemas espaciales gracias a su control eficiente sobre la administración de recursos, lo que es crucial cuando se procesan grandes volúmenes de datos geoespaciales o imágenes satelitales. Este libro está diseñado para demostrar cómo Rust puede convertirse en una herramienta esencial para abordar desafíos espaciales complejos, ofreciendo un equilibrio perfecto entre rendimiento, seguridad y claridad en el código. A través de ejemplos prácticos, aprenderás a utilizar Rust para enfrentar tareas de análisis espacial, desde la manipulación de vastos conjuntos de datos hasta la construcción de sistemas altamente optimizados para el procesamiento geoespacial, todo con el poder y la eficiencia de este lenguaje.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Prefacio</span>"
    ]
  },
  {
    "objectID": "index.html#créditos",
    "href": "index.html#créditos",
    "title": "Rust Espacial",
    "section": "Créditos",
    "text": "Créditos\nMuchos conceptos y ejemplos obtenidos del libro “El Lenguaje de Programación Rust” creado por Steve Klabnik y Carol Nichols, con contribuciones de la Comunidad Rust",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Prefacio</span>"
    ]
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "2  Introducción",
    "section": "",
    "text": "2.1 ¿Qué es Rust?\nRust es un lenguaje de programación de sistemas que prioriza el rendimiento, la seguridad y la concurrencia sin sacrificar la experiencia del desarrollador. Su diseño se enfoca en evitar errores comunes como las condiciones de carrera, desbordamientos de memoria y fugas de recursos, todo mientras mantiene la flexibilidad de los lenguajes de bajo nivel. Al ofrecer un control preciso sobre la memoria sin necesidad de un recolector de basura, Rust se ha convertido en una opción favorita tanto para el desarrollo de sistemas críticos como para aplicaciones de alto rendimiento, desde servidores web hasta sistemas embebidos.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introducción</span>"
    ]
  },
  {
    "objectID": "intro.html#objetivos",
    "href": "intro.html#objetivos",
    "title": "2  Introducción",
    "section": "2.2 Objetivos",
    "text": "2.2 Objetivos\n\nObjetivo General\nEl objetivo principal de este libro es proporcionar a los lectores una comprensión sólida y práctica de Rust, enfocándose en su aplicación para la resolución de problemas espaciales y geoespaciales. A lo largo del libro, los lectores adquirirán las habilidades necesarias para desarrollar soluciones eficientes, robustas y seguras, utilizando Rust como herramienta fundamental en el análisis espacial.\n\n\nObjetivos Específicos\n\nIntroducir los conceptos fundamentales de Rust: Explicar de manera clara los principios básicos del lenguaje, como su sistema de ownership, estructuras de datos y programación funcional, para que el lector pueda aplicarlos en diferentes contextos.\nDemostrar la aplicación de Rust en problemas espaciales: Proporcionar ejemplos prácticos y detallados que muestren cómo Rust puede ser utilizado para procesar grandes volúmenes de datos geoespaciales, optimizando tanto el rendimiento como la eficiencia.\nComparar Rust con otros lenguajes usados en análisis espacial: Ofrecer una visión comparativa de Rust frente a lenguajes como Python y R, resaltando las ventajas y casos en los que Rust puede ser una mejor opción en la resolución de problemas complejos de análisis espacial.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introducción</span>"
    ]
  },
  {
    "objectID": "intro.html#descripción-del-libro",
    "href": "intro.html#descripción-del-libro",
    "title": "2  Introducción",
    "section": "2.3 Descripción del Libro",
    "text": "2.3 Descripción del Libro\nEste libro está diseñado para guiar al lector desde la instalación de Rust hasta su aplicación en análisis espacial, proporcionando una base sólida en el lenguaje y sus conceptos clave. Comenzamos con el Capítulo 3: Instalación, donde te ayudaremos a configurar tu entorno de trabajo. A continuación, en el Capítulo 4: Conceptos Básicos, introducimos los fundamentos del lenguaje, necesarios para entender los ejemplos prácticos. Luego, el Capítulo 5: Ownership explora el sistema de propiedad de Rust, que es esencial para manejar la memoria de manera eficiente. El Capítulo 6: Struct presenta la construcción de estructuras de datos personalizadas, un aspecto clave en la creación de modelos complejos. En el Capítulo 7: Rust en Producción, discutimos las mejores prácticas para llevar proyectos de Rust al entorno productivo, asegurando que tu código sea escalable y mantenible. Posteriormente, en el Capítulo 8: Rust Espacial, nos adentramos en la aplicación de Rust para resolver problemas espaciales complejos, mostrando su capacidad para manejar grandes volúmenes de datos geoespaciales. En el Capítulo 9: Programación Funcional, exploramos cómo Rust incorpora paradigmas funcionales para simplificar la manipulación de datos y mejorar la legibilidad del código. Finalmente, en el Capítulo 10: Otros Lenguajes, comparamos Rust con otros lenguajes populares en el ámbito del análisis espacial, como R y Python, destacando sus ventajas y desventajas.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introducción</span>"
    ]
  },
  {
    "objectID": "intro.html#perfil-del-lector",
    "href": "intro.html#perfil-del-lector",
    "title": "2  Introducción",
    "section": "2.4 Perfil del Lector",
    "text": "2.4 Perfil del Lector\nEste libro está orientado a profesionales con experiencia intermedia o avanzada en programación, que tengan nociones de otros lenguajes como Python, R o C++. Si ya has trabajado con lenguajes de programación y estás buscando expandir tu conocimiento hacia Rust, este libro es para ti. No es necesario ser un experto en análisis espacial, pero se espera que tengas una comprensión básica de los principios de programación y estés familiarizado con la resolución de problemas complejos.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introducción</span>"
    ]
  },
  {
    "objectID": "intro.html#resumen",
    "href": "intro.html#resumen",
    "title": "2  Introducción",
    "section": "2.5 Resumen",
    "text": "2.5 Resumen\nEn resumen, este libro te guiará a través de los fundamentos de Rust, proporcionándote las habilidades necesarias para aplicar el lenguaje en la resolución de problemas espaciales. Desde la instalación hasta la programación funcional, cada capítulo está diseñado para ofrecerte una comprensión progresiva del lenguaje y su uso práctico. Al final, habrás adquirido las herramientas para implementar soluciones eficientes y robustas en Rust, ya sea en el análisis espacial o en otros campos de alta demanda técnica.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introducción</span>"
    ]
  },
  {
    "objectID": "install.html",
    "href": "install.html",
    "title": "3  Instalación",
    "section": "",
    "text": "3.1 Intalar Rust\nEl primer paso es instalar Rust. Descargaremos Rust a través de rustup, una herramienta de línea de comandos para administrar las versiones de Rust y las herramientas asociadas. Necesitarás una conexión a Internet para la descarga.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Instalación</span>"
    ]
  },
  {
    "objectID": "install.html#intalar-rust",
    "href": "install.html#intalar-rust",
    "title": "3  Instalación",
    "section": "",
    "text": "3.1.1 Instalación de rustup en Linux o macOS\nSi estás utilizando Linux o macOS, abre una terminal y escribe lo siguiente\ncurl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf | sh\nEl comando descarga un script y comienza la instalación de la herramienta rustup, que instala la última versión estable de Rust. Es posible que se te solicite tu contraseña. Si la instalación es exitosa, aparecerá la siguiente línea:\nRust is installed now. Great!\nTambién necesitarás un enlazador, que es un programa que Rust utiliza para unir sus salidas compiladas en un solo archivo. Es probable que ya lo tengas. Si obtienes errores de enlace, debes instalar un compilador C, que generalmente incluye un enlazador. Un compilador C también es útil porque algunos paquetes comunes de Rust dependen de código C y necesitarán un compilador C.\nEn macOS, puedes obtener un compilador C ejecutando:\nxcode-select --install\nLos usuarios de Linux deben instalar generalmente GCC o Clang, según la documentación de su distribución. Por ejemplo, si usas Ubuntu, puede instalar el paquete build-essential.\n\n\n3.1.2 Instalación de rustup en Windows\nEn Windows, ve a https://www.rust-lang.org/tools/install y sigue las instrucciones para instalar Rust. En algún momento de la instalación, recibirás un mensaje para instalar Visual Studio. Este provee un linker y las bibliotecas nativas necesarias para compilar programas.\nPara obtener las herramientas de compilación, deberás instalar Visual Studio. Cuando se te pregunte qué paquetes de trabajo instalar, incluye:\n\n“Desarrollo de escritorio con C ++”\nEl SDK de Windows 10 o 11\nEl componente de paquete de idioma inglés, junto con cualquier otro paquete de idioma de tu elección\n\nEl resto de este libro usa comandos que funcionan tanto en cmd.exe como en PowerShell. Si hay diferencias específicas, explicaremos cuál usar.\n\n\n3.1.3 Solución de problemas\nPara verificar si has instalado Rust correctamente, abra una shell y escribe esta línea:\n$ rustc --version\nDeberías ver el número de versión, el hash de confirmación y la fecha de confirmación de la última versión estable que se ha publicado, en el siguiente formato:\nrustc x.y.z (abcabcabc yyyy-mm-dd)\nSi ves esta información, ¡has instalado Rust correctamente! Si no ves esta información, verifica que Rust esté en la variable de sistema %PATH% de la siguiente manera.\nEn Windows CMD, usa:\n&gt; echo %PATH%\nEn PowerShell, usa:\n&gt; echo $env:Path\nEn Linux y macOS, usa:\n$ echo $PATH\n\n\n3.1.4 Actualización y desinstalación\nUna vez que Rust se instala a través de rustup, actualizar a una versión recién lanzada es fácil. Desde tu shell, ejecuta el siguiente script de actualización:\n$ rustup update\nPara desinstalar Rust y rustup, ejecuta el siguiente script de desinstalación desde tu shell:\n$ rustup self uninstall\n\n\n3.1.5 Documentación local\nLa instalación de Rust también incluye una copia local de la documentación para que puedas leerla sin conexión. Ejecuta rustup doc para abrir la documentación local en tu navegador.\nEn cualquier momento en que se proporcione un tipo o una función de la biblioteca estándar y no estés seguro de lo que hace o cómo usarlo, usa la documentación de la interfaz de programación de aplicaciones (API) para averiguarlo.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Instalación</span>"
    ]
  },
  {
    "objectID": "install.html#hello-world",
    "href": "install.html#hello-world",
    "title": "3  Instalación",
    "section": "3.2 Hello World",
    "text": "3.2 Hello World\nAhora que has instalado Rust, es hora de escribir tu primer programa en Rust. Es tradicional cuando se aprende un nuevo lenguaje escribir un pequeño programa que imprima el texto ¡Hola, mundo! en la pantalla.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Instalación</span>"
    ]
  },
  {
    "objectID": "install.html#instalar-cargo",
    "href": "install.html#instalar-cargo",
    "title": "3  Instalación",
    "section": "3.3 Instalar Cargo",
    "text": "3.3 Instalar Cargo\nCargo es el sistema de compilación y administrador de paquetes de Rust. La mayoría de los Rustaceans usan esta herramienta para administrar sus proyectos Rust porque Cargo maneja muchas tareas para ti, como compilar tu código, descargar las bibliotecas de las que depende tu código y compilar esas bibliotecas. (Llamamos dependencias a las bibliotecas de las que depende tu código).\nLos programas Rust más simples, como el que hemos escrito hasta ahora, no tienen dependencias. Si hubiéramos construido el proyecto “¡Hola, mundo!” con Cargo, sólo usaría la parte de Cargo que maneja la compilación de tu código. A medida que escribas programas Rust más complejos, agregarás dependencias, y si comienzas un proyecto usando Cargo, agregar dependencias será mucho más fácil de hacer.\nDebido a que la gran mayoría de los proyectos Rust usan Cargo, el resto de este libro asume que también estás usando Cargo. Cargo viene instalado con Rust si usaste los instaladores oficiales que se discuten en la sección [“Installation”][installation]. Si instalaste Rust a través de algunos otros medios, verifica si Cargo está instalado ingresando lo siguiente en tu terminal:\n$ cargo --version\nSi ves un número de versión, ¡lo tienes! Si ves un error, como command not found, consulta la documentación de tu método de instalación para determinar cómo instalar Cargo por separado.\n\n3.3.1 Creación de un proyecto con Cargo\nVamos a crear un nuevo proyecto usando Cargo y ver cómo difiere de nuestro proyecto original “¡Hola, mundo!”. Navega de vuelta a tu directorio proyectos (o dondequiera que hayas decidido almacenar tu código). Luego, en cualquier sistema operativo, ejecuta lo siguiente:\n$ cargo new hello_cargo\n$ cd hello_cargo\nEl primer comando crea un nuevo directorio y proyecto llamado hello_cargo. Hemos nombrado a nuestro proyecto hello_cargo, y Cargo crea sus archivos en un directorio con el mismo nombre.\nVe al directorio hello_cargo y lista los archivos. Verás que Cargo ha generado dos archivos y un directorio para nosotros: un archivo Cargo.toml y un directorio src con un archivo main.rs dentro.\nTambién ha inicializado un nuevo repositorio Git junto con un archivo .gitignore. Los archivos Git no se generarán si ejecutas cargo new dentro de un repositorio Git existente; puedes anular este comportamiento usando cargo new --vcs=git.\n\nNota: Git es un sistema de control de versiones común. Puedes cambiar cargo new para usar un sistema de control de versiones diferente o ningún sistema de control de versiones usando la bandera --vcs. Ejecuta cargo new --help para ver las opciones disponibles.\n\nAbre Cargo.toml en tu editor de texto de elección. Debería verse similar al código del Listado 1-2.\n\n[package]\nname = \"hello_cargo\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n\n[dependencies]\n\nEste archivo está en el formato TOML (Tom’s Obvious, Minimal Language), que es el formato de configuración de Cargo.\nLa primera línea, [package], es un encabezado de sección que indica que las siguientes declaraciones están configurando un paquete. A medida que agreguemos más información a este archivo, agregaremos otras secciones.\nLas próximas tres líneas establecen la información de configuración que Cargo necesita para compilar tu programa: el nombre, la versión y la edición de Rust que se usará. Hablaremos sobre la entrada edition en [Apéndice E][appendix-e] .\nLa última línea, [dependencies], es el comienzo de una sección para que enumere cualquier dependencia de tu proyecto. En Rust, los paquetes de código se denominan crates. No necesitaremos otros crates para este proyecto, pero lo haremos en el primer proyecto del Capítulo 2, por lo que usaremos esta sección de dependencias hasta entonces.\nAhora abre src/main.rs y echa un vistazo:\nNombre de archivo: src/main.rs\nfn main() {\n    println!(\"Hello, world!\");\n}\n¡Cargo ha generado un programa “Hello, world!”/“¡Hola, mundo!” para ti, ¡igual que el que escribimos enl Listado 1-1! Hasta ahora, las diferencias entre nuestro proyecto y el proyecto generado por Cargo son que Cargo colocó el código en el directorio src y tenemos un archivo de configuración Cargo.toml en el directorio superior.\nCargo espera que tus archivos de origen vivan dentro del directorio src. El directorio del proyecto de nivel superior es solo para archivos README, información de licencia, archivos de configuración y cualquier otra cosa que no esté relacionada con tu código. Usar Cargo te ayuda a organizar tus proyectos. Hay un lugar para todo, y todo está en su lugar.\nSi comenzaste un proyecto que no usa Cargo, como hicimos con el proyecto “¡Hola, mundo!”, puedes convertirlo en un proyecto que sí use Cargo. Mueve el código del proyecto al directorio src y crea un archivo Cargo.toml adecuado.\n\n\n3.3.2 Construir y ejecutar un proyecto de Cargo\nAhora veamos qué es diferente cuando construimos y ejecutamos el programa “¡Hola, mundo!” con Cargo. ¡Desde tu directorio hello_cargo, construye tu proyecto ingresando el siguiente comando:\n$ cargo build\n   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)\n    Finished dev [unoptimized + debuginfo] target(s) in 2.85 secs\nEste comando crea un archivo ejecutable en target/debug/hello_cargo (o *target_cargo.exe* en Windows) en lugar de en tu directorio actual. Debido a que la compilación predeterminada es una compilación de depuración, Cargo coloca el binario en un directorio llamado debug. Puedes llamar al ejecutable con este comando:\n$ ./target/debug/hello_cargo # o .\\target\\debug\\hello_cargo.exe en Windows\nHello, world!\nSi todo va bien, Hello, world! debería imprimirse en la terminal. Ejecutar cargo build por primera vez también hace que Cargo cree un nuevo archivo en el nivel superior: Cargo.lock. Este archivo rastrea las versiones exactas de las dependencias de tu proyecto. Este proyecto no tiene dependencias, por lo que el archivo es un poco escaso. Nunca necesitarás cambiar este archivo manualmente; Cargo administra su contenido para ti.\nAcabamos de construir un proyecto con cargo build y ejecutarlo con ./target/debug/hello_cargo, pero también podemos usar cargo run para compilar el código y luego llamar al ejecutable resultante en un solo comando:\n$ cargo run\n    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs\n     Running `target/debug/hello_cargo`\nHello, world!\nUsar cargo run es más conveniente que tener que recordar ejecutar cargo build y luego usar la ruta completa al binario, por lo que la mayoría de los desarrolladores usan cargo run.\nTen en cuenta que esta vez no vimos salida que indicara que Cargo estaba compilando hello_cargo. Cargo supo que los archivos no habían cambiado, por lo que no volvió a construir, sino que solo ejecutó el binario. Si hubieras modificado tu código fuente, Cargo habría reconstruido el proyecto antes de ejecutarlo, y habrías visto esta salida:\n$ cargo run\n   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.33 secs\n     Running `target/debug/hello_cargo`\nHello, world!\nCargo también proporciona un comando llamado cargo check. Este comando comprueba rápidamente tu código para asegurarse de que compila, pero no produce un ejecutable:\n$ cargo check\n   Checking hello_cargo v0.1.0 (file:///projects/hello_cargo)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.32 secs\n¿Por qué no querrías un ejecutable? A menudo, cargo check es mucho más rápido que cargo build porque omite el paso de producir un ejecutable. Si estás verificando continuamente tu trabajo mientras escribes el código, usar cargo check acelerará el proceso de informarte si tu proyecto todavía aún está compilando. ¡Por lo tanto, muchos Rustaceans ejecutan cargo check periódicamente mientras escriben su programa para asegurarse de que compila! Luego ejecutan cargo build cuando están listos para usar el ejecutable.\nResumamos lo que hemos aprendido hasta ahora sobre Cargo:\n\nPodemos crear un proyecto usando cargo new.\nPodemos construir un proyecto usando cargo build.\nPodemos construir y ejecutar un proyecto en un solo paso usando cargo run.\nPodemos construir un proyecto sin producir un binario para verificar errores usando cargo check.\nEn lugar de guardar el resultado de la compilación en el mismo directorio que nuestro código, Cargo lo almacena en el directorio target/debug.\n\nUna ventaja adicional de usar Cargo es que los comandos son los mismos sin importar en qué sistema operativo estés trabajando. Por lo tanto, en este punto, ya no proporcionaremos instrucciones específicas para Linux y macOS versus Windows.\n\n\n3.3.3 Construyendo una versión de lanzamiento\nCuando tu proyecto finalmente esté listo para su lanzamiento, puedes usar cargo build --release para compilarlo con optimizaciones. Este comando creará un ejecutable en target/release en lugar de target/debug. Las optimizaciones hacen que tu código Rust se ejecute más rápido, pero al activarlos se alarga el tiempo que tarda tu programa en compilarse. Es por eso que hay dos perfiles diferentes: uno para el desarrollo, cuando deseas reconstruir rápidamente y con frecuencia, y otro para construir el programa final que le darás al usuario, que no se reconstruirá repetidamente y que se ejecutará lo más rápido posible. Si estás midiendo el tiempo de ejecución de tu código, asegúrate de ejecutar cargo build --release y realizar la prueba de rendimiento con el ejecutable en target/release.\n\n\n3.3.4 Cargo como convención\nCon proyectos simples, Cargo no proporciona mucho valor por sobre sólo usar rustc, pero demostrará su valor a medida que tus programas se vuelvan más intrincados. Una vez que los programas crecen a múltiples archivos o necesitan una dependencia, es mucho más fácil dejar que Cargo coordine la construcción.\nAunque el proyecto hello_cargo es simple, ahora usas muchas de las herramientas reales que usarás en el resto de tu carrera en Rust. De hecho, para trabajar en cualquier proyecto existente, puedes usar los siguientes comandos para verificar el código usando Git, cambiar al directorio del proyecto y construir:\n$ git clone example.org/someproject\n$ cd someproject\n$ cargo build\nPara obtener más información sobre Cargo, consulta su documentación.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Instalación</span>"
    ]
  },
  {
    "objectID": "install.html#extensiones-para-vs-code",
    "href": "install.html#extensiones-para-vs-code",
    "title": "3  Instalación",
    "section": "3.4 Extensiones para VS Code",
    "text": "3.4 Extensiones para VS Code\nPuede encontrar e instalar la extensión rust-analyzer desde VS Code a través de la vista Extensiones (⇧⌘X) y buscando rust-analyzer. Debe instalar la versión de lanzamiento.\n\n\n\nExtensión para Visual Studio Code llamada rust-analyzer\n\n\nPuedes consultar la documentación de la extensión en https://rust-analyzer.github.io.\nhttps://www.youtube.com/watch?v=Vde3-UUZAvU",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Instalación</span>"
    ]
  },
  {
    "objectID": "concepts.html",
    "href": "concepts.html",
    "title": "4  Conceptos Básicos",
    "section": "",
    "text": "4.1 Variables y Mutabilidad\nEn Rust, las variables son inmutables por defecto, lo que promueve la seguridad y la concurrencia. Esto significa que una vez que se asigna un valor a una variable, no puede ser cambiado. Sin embargo, Rust permite optar por variables mutables si es necesario.\nPor ejemplo, el siguiente código da un error porque intenta reasignar un valor a la variable x sin hacerla mutable:\nEste error es útil porque garantiza que no modifiquemos accidentalmente variables que deben permanecer inmutables, lo que puede causar errores difíciles de detectar.\nSi necesitas cambiar el valor de una variable, puedes hacerla mutable usando mut:\nCon mut, el valor de x puede cambiar de 5 a 6. La mutabilidad es útil en muchos casos, pero usar variables inmutables puede ayudar a evitar errores y hacer que tu código sea más fácil de entender.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Conceptos Básicos</span>"
    ]
  },
  {
    "objectID": "concepts.html#variables-y-mutabilidad",
    "href": "concepts.html#variables-y-mutabilidad",
    "title": "4  Conceptos Básicos",
    "section": "",
    "text": "fn main() {\n    let x = 5;\n    println!(\"El valor de x es: {x}\");\n    x = 6; // Error: no se puede asignar dos veces a una variable inmutable.\n}\n\n\n\nfn main() {\n    let mut x = 5;\n    println!(\"El valor de x es: {x}\");\n    x = 6;\n    println!(\"El nuevo valor de x es: {x}\");\n}",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Conceptos Básicos</span>"
    ]
  },
  {
    "objectID": "concepts.html#tipos-de-datos-básicos",
    "href": "concepts.html#tipos-de-datos-básicos",
    "title": "4  Conceptos Básicos",
    "section": "4.2 Tipos de datos básicos",
    "text": "4.2 Tipos de datos básicos\nRust es un lenguaje fuertemente tipado, lo que significa que cada valor debe tener un tipo específico. Estos tipos se dividen principalmente en dos categorías: tipos escalares y tipos compuestos. En esta sección, nos centraremos en los tipos escalares, que representan un valor único.\n\n4.2.1 Tipos Escalares\nLos tipos escalares incluyen enteros, números de coma flotante, caracteres y booleanos. A continuación, se presenta una tabla con los principales tipos de datos y ejemplos de sus valores literales:\n\n\n\n\n\n\n\n\nTipo\nSintaxis\nEjemplos\n\n\n\n\nEnteros con signo\ni8, i16, i32, i64, i128, isize\n-10, 0, 1_000, 123_i64\n\n\nEnteros sin signo\nu8, u16, u32, u64, u128, usize\n0, 123, 10_u16\n\n\nNúmeros de coma flotante\nf32, f64\n3.14, -10.0e20, 2_f32\n\n\nValores escalares Unicode\nchar\n‘a’, ‘α’, ‘∞’\n\n\nBooleanos\nbool\ntrue, false\n\n\n\nAncho de los Tipos\nCada tipo tiene un tamaño específico en memoria:\n\niN, uN, y fN tienen un ancho de N bits.\nisize y usize tienen el ancho de un puntero, lo que depende de la arquitectura del sistema (generalmente 32 o 64 bits).\nchar tiene un tamaño de 32 bits, lo que permite representar cualquier carácter Unicode.\nbool ocupa 8 bits de espacio en memoria.\n\nEjemplo de Uso\nPodemos ver cómo se utilizan estos tipos de datos en un programa simple:\nfn main() {\n    let entero_con_signo: i32 = -500;\n    let entero_sin_signo: u32 = 300;\n    let flotante: f64 = 3.1415;\n    let caracter: char = '∞';\n    let booleano: bool = true;\n    \n    println!(\"Entero con signo: {}\", entero_con_signo);\n    println!(\"Entero sin signo: {}\", entero_sin_signo);\n    println!(\"Flotante: {}\", flotante);\n    println!(\"Carácter: {}\", caracter);\n    println!(\"Booleano: {}\", booleano);\n}\nEste ejemplo muestra cómo declarar y utilizar los diferentes tipos de datos en Rust, cada uno con su correspondiente tipo y valor literal.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Conceptos Básicos</span>"
    ]
  },
  {
    "objectID": "concepts.html#control-de-flujos",
    "href": "concepts.html#control-de-flujos",
    "title": "4  Conceptos Básicos",
    "section": "4.3 Control de Flujos",
    "text": "4.3 Control de Flujos\nEn Rust, el control de flujos permite dirigir la ejecución del programa basándose en condiciones y repeticiones. Rust ofrece varias estructuras para controlar el flujo de la ejecución del código, como if para condiciones y bucles para repetir bloques de código.\nAquí tienes una tabla con las operaciones lógicas y su sintaxis en Rust, qué se utilizan en control de flujos:\n\n\n\n\n\n\n\n\n\nOperación\nSímbolo\nDescripción\nEjemplo\n\n\n\n\nAND lógico\n&&\nVerdadero si ambas expresiones son verdaderas\ntrue && false (devuelve false)\n\n\nOR lógico\n||\nVerdadero si al menos una expresión es verdadera\ntrue || false (devuelve true)\n\n\nNOT lógico\n!\nInvierte el valor de verdad de una expresión\n!true (devuelve false)\n\n\nIgualdad\n==\nVerdadero si ambas expresiones son iguales\n5 == 5 (devuelve true)\n\n\nDesigualdad\n!=\nVerdadero si ambas expresiones no son iguales\n5 != 6 (devuelve true)\n\n\nMayor que\n&gt;\nVerdadero si la primera expresión es mayor que la segunda\n6 &gt; 3 (devuelve true)\n\n\nMenor que\n&lt;\nVerdadero si la primera expresión es menor que la segunda\n3 &lt; 5 (devuelve true)\n\n\nMayor o igual que\n&gt;=\nVerdadero si la primera expresión es mayor o igual a la segunda\n5 &gt;= 5 (devuelve true)\n\n\nMenor o igual que\n&lt;=\nVerdadero si la primera expresión es menor o igual a la segunda\n3 &lt;= 4 (devuelve true)\n\n\n\n\n4.3.1 Expresión if\nEn Rust, la expresión if evalúa una condición booleana y ejecuta un bloque de código dependiendo de si la condición es verdadera (true) o falsa (false). A diferencia de otros lenguajes, if en Rust es una expresión, lo que significa que puede devolver un valor.\nfn main() {\n    let numero = 5;\n\n    if numero &gt; 3 {\n        println!(\"El número es mayor que 3.\");\n    } else {\n        println!(\"El número es 3 o menor.\");\n    }\n}\nTambién se puede usar la expresión if para asignar valores:\nlet condicion = true;\nlet numero = if condicion { 5 } else { 6 };\nEs importante recordar que las ramas del if deben devolver el mismo tipo.\n\n\n4.3.2 Bucles\nRust proporciona tres tipos de bucles: loop, while, y for.\n\nloop\n\nEjecuta un bloque de código indefinidamente hasta que se detenga explícitamente con una instrucción break.\n\n\nfn main() {\n    let mut contador = 0;\n\n    loop {\n        contador += 1;\n        println!(\"Contador: {contador}\");\n\n        if contador == 5 {\n            break;  // Detiene el bucle cuando contador es 5\n        }\n    }\n}\n\nwhile\n\nEjecuta un bloque de código mientras una condición booleana sea verdadera.\n\n\nfn main() {\n    let mut numero = 3;\n\n    while numero != 0 {\n        println!(\"{numero}\");\n        numero -= 1;\n    }\n}\n\nfor\n\nRecorre elementos de una colección o un rango.\n\n\nfn main() {\n    for numero in 1..4 {\n        println!(\"{numero}\");\n    }\n}\n\n\n4.3.3 break y continue\nbreak: Termina el bucle inmediatamente.\ncontinue: Salta al siguiente ciclo del bucle sin ejecutar el resto del bloque actual.\nEjemplo combinando ambos:\nfn main() {\n    for numero in 1..10 {\n        if numero == 5 {\n            continue;  // Salta cuando número es 5\n        } else if numero == 8 {\n            break;  // Termina el bucle cuando número es 8\n        }\n        println!(\"Número: {numero}\");\n    }\n}",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Conceptos Básicos</span>"
    ]
  },
  {
    "objectID": "concepts.html#bloques-y-ámbitos",
    "href": "concepts.html#bloques-y-ámbitos",
    "title": "4  Conceptos Básicos",
    "section": "4.4 Bloques y Ámbitos",
    "text": "4.4 Bloques y Ámbitos\nEn Rust, un bloque es un conjunto de declaraciones y expresiones encerradas entre llaves {}, que define un ámbito o scope. Los bloques permiten organizar el código y controlar la visibilidad y la duración de las variables.\n\n4.4.1 Bloques\nUn bloque es simplemente un conjunto de instrucciones encerradas entre {}. Puedes usarlos en funciones, if, while, for y otras estructuras de control de flujo. Por ejemplo:\n\nfn main() {\n    let x = 5;\n    let y = {\n        let x = 3;\n        x + 1  // Este bloque devuelve 4\n    };\n    \n    println!(\"El valor de y es: {y}\");  // Imprime 4\n}\nEn este caso, el valor de y se asigna al resultado del bloque {}, que devuelve 4. Dentro del bloque, el valor de x es 3, pero fuera del bloque sigue siendo 5. Esto demuestra cómo los bloques crean un nuevo ámbito.\n\n\n4.4.2 Ámbitos (Scope)\nCada variable tiene un ámbito, que es el área del código donde la variable está visible y disponible para su uso. El ámbito comienza cuando se declara la variable y termina cuando el bloque que contiene la variable finaliza.\nfn main() {\n    let x = 5; // El ámbito de `x` comienza aquí\n\n    {\n        let y = 10;  // El ámbito de `y` comienza aquí\n        println!(\"Dentro del bloque: x = {x}, y = {y}\");\n    }  // El ámbito de `y` termina aquí\n\n    // Aquí, `y` ya no es accesible, pero `x` aún lo es\n    println!(\"Fuera del bloque: x = {x}\");\n}\nEn el ejemplo anterior, y solo existe dentro del bloque interno. Intentar acceder a y fuera de ese bloque resultaría en un error, ya que su ámbito ha terminado. Sin embargo, x sigue accesible porque fue declarada en un ámbito más amplio (el bloque principal).\n\n\n4.4.3 Sombra de Variables (Variable Shadowing)\nRust permite sombras de variables, lo que significa que puedes declarar una nueva variable con el mismo nombre en un nuevo bloque, y esta nueva variable “sombrea” la anterior.\nfn main() {\n    let x = 5;\n\n    {\n        let x = x * 2;  // Esta nueva `x` sombrea la anterior\n        println!(\"El valor de x dentro del bloque es: {x}\");  // Imprime 10\n    }\n\n    println!(\"El valor de x fuera del bloque es: {x}\");  // Imprime 5\n}\nLa variable x dentro del bloque es independiente de la x fuera del bloque, y la versión de x fuera del bloque no se ve afectada por los cambios realizados dentro del bloque interno.\n\n\n4.4.4 Duración de Vida (Lifetimes)\nEl ámbito también está relacionado con el concepto de duración de vida en Rust, que se refiere a cuánto tiempo vive una referencia o variable. Aunque no se necesita usar anotaciones de tiempo de vida en muchos casos, se volverán importantes cuando trabajes con referencias y prestamistas en bloques más complejos.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Conceptos Básicos</span>"
    ]
  },
  {
    "objectID": "concepts.html#funciones",
    "href": "concepts.html#funciones",
    "title": "4  Conceptos Básicos",
    "section": "4.5 Funciones",
    "text": "4.5 Funciones\nEn Rust, las funciones son un componente clave para organizar y reutilizar código. Permiten dividir el programa en partes más pequeñas y manejables. Toda función en Rust debe estar declarada con el tipo de datos que espera recibir (parámetros) y el tipo de dato que devolverá (si corresponde).\nDefinición de Funciones\nLa sintaxis básica para definir una función en Rust es la siguiente:\nfn nombre_de_la_funcion(parámetros: tipo) -&gt; tipo_de_retorno {\n    // cuerpo de la función\n}\n\nfn: Indica que estamos declarando una función.\nnombre_de_la_funcion: El nombre de la función, que sigue las convenciones de estilo snake_case.\nparámetros: Una lista de parámetros opcionales que la función toma como entrada.\ntipo_de_retorno: El tipo de valor que la función devolverá (si no devuelve nada, se omite).\nEl cuerpo de la función es donde se especifica el comportamiento.\n\nEjemplo Simple de Función\nAquí tienes un ejemplo de una función que toma dos números enteros como parámetros y devuelve su suma:\nfn sumar(a: i32, b: i32) -&gt; i32 {\n    a + b  // El valor de retorno es la última expresión\n}\n\nfn main() {\n    let resultado = sumar(5, 3);\n    println!(\"El resultado es: {resultado}\");\n}\nEn este ejemplo:\n\nLa función devuelve un valor de tipo i32, que es la suma de a y b.\nLa última expresión dentro de una función se devuelve automáticamente si no se termina con un punto y coma.\n\nParámetros\nLos parámetros se definen dentro de los paréntesis cuando declaras una función, especificando tanto el nombre como el tipo de dato. Puedes pasar múltiples parámetros:\nfn multiplicar(x: i32, y: i32) -&gt; i32 {\n    x * y\n}\nRust requiere que especifiques el tipo de todos los parámetros de la función.\nValores de Retorno\nUna función puede devolver un valor usando una expresión o una instrucción return opcional. En Rust, la última expresión en el cuerpo de la función sin punto y coma se devuelve automáticamente.\nfn cuadrado(x: i32) -&gt; i32 {\n    return x * x;  // También puedes usar `return` explícitamente\n}\nSi no deseas que la función devuelva un valor, puedes omitir la flecha -&gt; y el tipo de retorno, lo que significa que la función devolverá la unidad ():\nfn saludar() {\n    println!(\"Hola, mundo!\");\n}\nFunciones con Referencias\nRust también permite pasar referencias a las funciones, lo que es útil cuando no deseas transferir la propiedad de un valor. Las referencias permiten que la función lea el valor sin tomar posesión de él:\nfn longitud(texto: &String) -&gt; usize {\n    texto.len()\n}\nEn este ejemplo, &String indica que la función toma una referencia al valor en lugar de transferir su propiedad.\nFunciones Anidadas\nPuedes definir funciones dentro de otras funciones en Rust, lo que se llama funciones anidadas. Esto puede ser útil para encapsular lógica específica dentro de un contexto limitado:\nfn main() {\n    fn interna() {\n        println!(\"Esta es una función anidada\");\n    }\n\n    interna();  // Llamando a la función anidada\n}\nFunciones con Tipos Genéricos\nRust permite que las funciones acepten tipos genéricos, lo que hace que las funciones sean más flexibles y reutilizables. Por ejemplo:\nfn imprimir_dos_veces&lt;T: std::fmt::Debug&gt;(x: T) {\n    println!(\"{:?} {:?}\", x, x);\n}\nAquí, T es un tipo genérico, y std::fmt::Debug es un trait que indica que el tipo debe poder imprimirse con {:?}.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Conceptos Básicos</span>"
    ]
  },
  {
    "objectID": "concepts.html#macros",
    "href": "concepts.html#macros",
    "title": "4  Conceptos Básicos",
    "section": "4.6 Macros",
    "text": "4.6 Macros\nEn Rust, las macros son una poderosa característica que permite escribir código que genera otros fragmentos de código durante la compilación. Las macros permiten realizar tareas repetitivas, trabajar con estructuras complejas y proporcionar una mayor flexibilidad que las funciones estándar.\nA diferencia de las funciones, las macros pueden aceptar un número variable de argumentos y no están limitadas a trabajar solo con tipos específicos. Además, las macros en Rust se expanden antes de que el código sea compilado, lo que las hace útiles para metaprogramación.\nMacros vs Funciones\nAunque las macros y las funciones pueden parecer similares, tienen algunas diferencias clave:\n\nFunciones: Se ejecutan en tiempo de ejecución y trabajan con parámetros de tipos específicos.\nMacros: Se expanden en código en tiempo de compilación, lo que permite generar fragmentos de código personalizados.\n\nPor ejemplo, una función recibe un número fijo de argumentos de un tipo determinado, mientras que una macro puede manejar un número variable de argumentos de cualquier tipo. La exclamación ! es lo que distingue a las macros de las funciones.\nMacros Más Comunes\nRust incluye varias macros predefinidas que son ampliamente utilizadas. Algunas de las más comunes son:\nprintln!: Imprime un mensaje formateado en la consola.\nfn main() {\n    println!(\"Hola, mundo!\");\n}\nvec!: Crea un vector con elementos iniciales.\nfn main() {\n    let v = vec![1, 2, 3];\n    println!(\"{:?}\", v);\n}\nLa macro vec! permite crear un vector con varios elementos sin tener que declarar su tipo explícitamente.\nDefincición de Macros\nLas macros se definen usando el macro sistema macro_rules!. A continuación, un ejemplo básico de cómo definir una macro que acepta dos expresiones y las imprime:\nmacro_rules! saludar {\n    ($nombre:expr) =&gt; {\n        println!(\"Hola, {}!\", $nombre);\n    };\n}\n\nfn main() {\n    saludar!(\"Rust\");\n}\nAquí, saludar! es la macro que toma un único argumento de tipo expresión ($nombre:expr) y genera una llamada a println! con ese argumento. El uso de $nombre:expr es parte de la sintaxis de las macros en Rust, que permite definir patrones y expandir el código.\nMacros con Múltiples Patrones\nLas macros pueden manejar múltiples patrones de entrada, lo que les permite comportarse de manera diferente dependiendo de cuántos o qué tipos de argumentos se les pasen:\nmacro_rules! sumar {\n    ($a:expr, $b:expr) =&gt; {\n        println!(\"La suma es: {}\", $a + $b);\n    };\n    ($a:expr, $b:expr, $c:expr) =&gt; {\n        println!(\"La suma es: {}\", $a + $b + $c);\n    };\n}\n\nfn main() {\n    sumar!(2, 3);         // La suma es: 5\n    sumar!(2, 3, 4);      // La suma es: 9\n}\nEn este ejemplo, la macro sumar! puede aceptar dos o tres argumentos y ejecutará una acción diferente según el número de parámetros proporcionados.\nMacros Recursivas\nRust también permite la creación de macros recursivas, que pueden llamarse a sí mismas hasta cumplir una condición. Esto es útil cuando necesitas generar estructuras de código repetitivas.\nmacro_rules! contador {\n    ($primero:expr) =&gt; {\n        println!(\"{}\", $primero);\n    };\n    ($primero:expr, $($resto:expr),*) =&gt; {\n        println!(\"{}\", $primero);\n        contador!($($resto),*);\n    };\n}\n\nfn main() {\n    contador!(1, 2, 3, 4, 5);\n}\nEste ejemplo imprime cada número en una nueva línea, y la macro se llama recursivamente hasta que solo queda un argumento.\nCuándo Usar Macros\nLas macros son útiles cuando:\n\nNecesitas generar código repetitivo.\nQuieres aceptar una cantidad variable de argumentos o tipos de entrada.\nQuieres realizar optimizaciones en tiempo de compilación.\n\nSin embargo, las macros deben usarse con cuidado, ya que pueden hacer que el código sea más difícil de leer y depurar debido a su naturaleza de metaprogramación. Se recomienda usarlas solo cuando las funciones no sean suficientes para el caso en cuestión.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Conceptos Básicos</span>"
    ]
  },
  {
    "objectID": "concepts.html#tipos-compuestos",
    "href": "concepts.html#tipos-compuestos",
    "title": "4  Conceptos Básicos",
    "section": "4.7 Tipos Compuestos",
    "text": "4.7 Tipos Compuestos\n\nTuplas\n\nAgrupan múltiples valores de diferentes tipos en una única entidad. La longitud de una tupla es fija, y los tipos de los elementos pueden variar.\n\n\nEjemplo de tupla:\n\nlet tupla: (i32, f64, char) = (500, 6.4, 'a');\nlet (x, y, z) = tupla;  // Destructuring para acceder a los valores\n\nArreglos (Arrays)\n\nLos arreglos contienen múltiples valores del mismo tipo. A diferencia de los vectores, los arreglos tienen una longitud fija que no puede cambiar.\n\n\nEjemplo de arreglo:\n\nlet arreglo: [i32; 5] = [1, 2, 3, 4, 5];  // Un arreglo de 5 enteros\nlet primer_elemento = arreglo[0];  // Acceder al primer elemento\nAquí tienes una tabla para los tipos compuestos:\n\n\n\n\n\n\n\n\nTipo\nSintaxis\nEjemplos\n\n\n\n\nTuplas\n(T1, T2, T3, …)\n(500, 6.4, ‘a’)\n\n\nArreglos\n[T; N] (T es tipo, N es tamaño)\n[1, 2, 3, 4, 5], [3.14; 3] (inicializa con 3.14 tres veces)",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Conceptos Básicos</span>"
    ]
  },
  {
    "objectID": "concepts.html#iteradores",
    "href": "concepts.html#iteradores",
    "title": "4  Conceptos Básicos",
    "section": "4.8 Iteradores",
    "text": "4.8 Iteradores\nUn iterador es una estructura que permite recorrer una secuencia de elementos, como un arreglo, una lista o cualquier colección de datos, uno a la vez. En Rust, los iteradores son una herramienta poderosa y flexible, que se pueden usar para manipular y procesar colecciones de manera eficiente y expresiva.\n¿Qué es un Iterador?\nEn Rust, un iterador es cualquier tipo que implemente el trait Iterator. Los iteradores proporcionan dos funciones principales:\n\nnext\n\nProporciona acceso al siguiente elemento en la secuencia. Cuando no hay más elementos, devuelve None.\n\nMétodos de adaptación\n\nMétodos como map, filter, y collect que permiten transformar los iteradores.\n\n\nEjemplo básico de uso de next:\nfn main() {\n    let numeros = vec![1, 2, 3];\n    let mut iter = numeros.iter();\n\n    println!(\"{:?}\", iter.next());  // Imprime Some(1)\n    println!(\"{:?}\", iter.next());  // Imprime Some(2)\n    println!(\"{:?}\", iter.next());  // Imprime Some(3)\n    println!(\"{:?}\", iter.next());  // Imprime None\n}\nCrear un Iterador\nLa mayoría de las colecciones en Rust pueden convertirse en iteradores usando el método iter. Para iterar sobre un vector o un array:\nfn main() {\n    let numeros = vec![1, 2, 3, 4, 5];\n    \n    for numero in numeros.iter() {\n        println!(\"{}\", numero);\n    }\n}\nEn este caso, numeros.iter() devuelve un iterador sobre el vector numeros. El ciclo for se encarga de llamar a next por nosotros y obtiene cada elemento en la secuencia.\nMétodos de Adaptación de Iteradores\nRust proporciona varios métodos de iterador que permiten transformar, filtrar y combinar secuencias de manera eficiente. Estos métodos no consumen el iterador, sino que devuelven un nuevo iterador, lo que permite encadenarlos de manera elegante.\nAlgunos de los métodos más comunes son:\n\nmap\n\nAplica una función a cada elemento y devuelve un nuevo iterador con los resultados.\n\n\nfn main() {\n    let numeros = vec![1, 2, 3, 4];\n    let cuadrados: Vec&lt;i32&gt; = numeros.iter().map(|x| x * x).collect();\n    println!(\"{:?}\", cuadrados);  // Imprime [1, 4, 9, 16]\n}\n\nfilter\n\nFiltra elementos según una condición.\n\n\nfn main() {\n    let numeros = vec![1, 2, 3, 4, 5];\n    let pares: Vec&lt;i32&gt; = numeros.iter().filter(|&&x| x % 2 == 0).collect();\n    println!(\"{:?}\", pares);  // Imprime [2, 4]\n}\n\ncollect\n\nConvierte un iterador en una colección, como un Vec, un HashMap, entre otros.\n\n\nfn main() {\n    let numeros = vec![1, 2, 3, 4];\n    let resultado: Vec&lt;i32&gt; = numeros.iter().map(|x| x + 1).collect();\n    println!(\"{:?}\", resultado);  // Imprime [2, 3, 4, 5]\n}\n\nenumerate\n\nAsigna un índice a cada elemento del iterador.\n\n\nfn main() {\n    let numeros = vec![\"a\", \"b\", \"c\"];\n    for (i, letra) in numeros.iter().enumerate() {\n        println!(\"Índice: {}, Letra: {}\", i, letra);\n    }\n}\nConsumo de Iteradores\nAlgunos métodos de iterador consumen el iterador, lo que significa que una vez que el método ha sido ejecutado, el iterador ya no puede ser utilizado. Algunos ejemplos de métodos que consumen iteradores son:\n\nsum\n\nCalcula la suma de todos los elementos de un iterador numérico.\n\n\nfn main() {\n    let numeros = vec![1, 2, 3, 4];\n    let suma: i32 = numeros.iter().sum();\n    println!(\"La suma es: {}\", suma);  // Imprime 10\n}\n\nfind\n\nBusca el primer elemento que cumpla con una condición.\n\n\nfn main() {\n    let numeros = vec![1, 2, 3, 4];\n    if let Some(num) = numeros.iter().find(|&&x| x == 3) {\n        println!(\"Número encontrado: {}\", num);  // Imprime 3\n    }\n}\nIteradores Inmutables y Mutables\nRust te permite crear tanto iteradores inmutables como iteradores mutables. Los iteradores inmutables (iter()) te permiten acceder a los elementos de una colección sin modificarla, mientras que los iteradores mutables (iter_mut()) te permiten modificar los elementos mientras los recorres.\nfn main() {\n    let mut numeros = vec![1, 2, 3, 4];\n\n    for num in numeros.iter_mut() {\n        *num += 1;\n    }\n    \n    println!(\"{:?}\", numeros);  // Imprime [2, 3, 4, 5]\n}\nCreación de Iteradores Personalizados\nAdemás de usar los iteradores integrados, también puedes implementar el trait Iterator para crear tus propios iteradores personalizados. Esto te permite definir cómo deben comportarse tus estructuras de datos al ser iteradas.\nstruct Contador {\n    actual: u32,\n    limite: u32,\n}\n\nimpl Contador {\n    fn nuevo(limite: u32) -&gt; Contador {\n        Contador { actual: 0, limite }\n    }\n}\n\nimpl Iterator for Contador {\n    type Item = u32;\n\n    fn next(&mut self) -&gt; Option&lt;Self::Item&gt; {\n        if self.actual &lt; self.limite {\n            self.actual += 1;\n            Some(self.actual)\n        } else {\n            None\n        }\n    }\n}\n\nfn main() {\n    let mut contador = Contador::nuevo(5);\n\n    while let Some(valor) = contador.next() {\n        println!(\"{}\", valor);\n    }\n}\nEn este ejemplo, se define un iterador personalizado Contador que genera una secuencia de números de 1 a limite.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Conceptos Básicos</span>"
    ]
  },
  {
    "objectID": "concepts.html#closures",
    "href": "concepts.html#closures",
    "title": "4  Conceptos Básicos",
    "section": "4.9 Closures",
    "text": "4.9 Closures\nUn closure (o cierre) en Rust es una función anónima que puede capturar variables del entorno en el que se define. Los closures son muy flexibles y pueden aceptar parámetros, devolver valores y, a diferencia de las funciones normales, pueden capturar y utilizar variables que no se les pasan explícitamente.\nLos closures se definen usando la siguiente sintaxis:\n|parametros| expresión\nSon comunes en Rust para trabajar con iteradores y otras operaciones funcionales, como map y filter.\nDefinición Básica\nAquí tienes un ejemplo básico de un closure que suma dos números:\nfn main() {\n    let suma = |a, b| a + b;\n    println!(\"La suma es: {}\", suma(2, 3));\n}\nEn este ejemplo:\n\n|a, b| es la lista de parámetros del closure.\na + b es la expresión que se ejecuta cuando se llama al closure.\nSe llama al closure con suma(2, 3), y el resultado es 5.\n\nCaptura de Variables\nUna característica clave de los closures es su capacidad para capturar variables del entorno en el que fueron definidos. Pueden capturar variables por referencia, por préstamo mutable o por posesión, dependiendo de cómo se utilicen.\nfn main() {\n    let x = 4;\n    let closure = |y| x + y;\n    println!(\"Resultado: {}\", closure(3));  // Imprime 7\n}\nEn este caso, el closure closure captura la variable x del entorno y la utiliza en su cuerpo.\nClosures que Capturan por Referencia, Mutable y por Posesión\nLos closures pueden capturar variables de diferentes maneras:\n\nPor referencia\n\nEl closure accede a la variable sin tomar posesión de ella.\n\n\nfn main() {\n    let x = 5;\n    let capturar_x = || println!(\"x: {}\", x);  // Captura `x` por referencia\n    capturar_x();\n}\n\nPor mutabilidad\n\nEl closure puede modificar la variable.\n\n\nfn main() {\n    let mut x = 5;\n    let mut modificar_x = || x += 1;  // Captura `x` por mutabilidad\n    modificar_x();\n    println!(\"x: {}\", x);  // Imprime 6\n}\n\nPor posesión\n\nEl closure toma posesión de la variable, lo que impide su uso fuera del closure.\n\n\nfn main() {\n    let x = String::from(\"Hola\");\n    let capturar_x = || {\n        let _y = x;  // Captura `x` por posesión\n    };\n    capturar_x();\n    // Aquí `x` ya no es accesible porque fue capturado por posesión\n}\nClosures con Tipos y Anotaciones de Parámetros\nEn la mayoría de los casos, Rust puede inferir los tipos de los parámetros de un closure, por lo que no es necesario especificarlos. Sin embargo, también puedes hacerlo explícitamente si lo deseas:\nfn main() {\n    let suma = |a: i32, b: i32| -&gt; i32 { a + b };\n    println!(\"La suma es: {}\", suma(10, 5));\n}\nEn este caso, hemos anotado los tipos de los parámetros (i32) y el tipo de retorno del closure (i32).\nClosures y Funciones\nA diferencia de las funciones, los closures pueden capturar variables del entorno. Sin embargo, los closures y las funciones comparten algunas similitudes. Los closures se pueden almacenar en variables, pasar como argumentos o devolver desde otras funciones, al igual que las funciones.\nLos closures también pueden ser pasados como parámetros a funciones que esperan un trait como Fn, FnMut, o FnOnce\nTraits Fn, FnMut, y FnOnce\nRust proporciona tres traits principales para closures, dependiendo de cómo el closure maneje las variables capturadas:\n\nFn: El closure no modifica ni toma posesión de las variables que captura. Se llama múltiples veces sin efectos secundarios.\nFnMut: El closure puede modificar las variables que captura, pero no toma posesión de ellas. Se llama múltiples veces, pero puede tener efectos secundarios.\nFnOnce: El closure toma posesión de las variables que captura, por lo que solo puede ser llamado una vez.\n\nPor ejemplo:\nfn ejecutar_closure&lt;F&gt;(f: F) \nwhere\n    F: Fn(i32) -&gt; i32 \n{\n    println!(\"Resultado: {}\", f(5));\n}\n\nfn main() {\n    let closure = |x| x + 1;\n    ejecutar_closure(closure);\n}\nAquí, ejecutar_closure acepta un parámetro F que implementa el trait Fn, lo que permite pasarle closures que no modifican las variables capturadas.\nClosures como Retorno\nTambién puedes devolver un closure desde una función, utilizando el trait adecuado:\nfn crear_closure() -&gt; impl Fn(i32) -&gt; i32 {\n    |x| x + 1\n}\n\nfn main() {\n    let mi_closure = crear_closure();\n    println!(\"Resultado: {}\", mi_closure(10));  // Imprime 11\n}\nAquí, la función crear_closure devuelve un closure que toma un entero y devuelve ese entero incrementado en uno.\nClosures en Iteradores\nLos closures son ampliamente utilizados en operaciones con iteradores, como map, filter, fold, entre otros. Estos métodos aceptan closures para realizar operaciones sobre cada elemento de una colección.\nPor ejemplo, el uso de un closure con map para elevar al cuadrado los números de un vector:\nfn main() {\n    let numeros = vec![1, 2, 3, 4];\n    let cuadrados: Vec&lt;i32&gt; = numeros.iter().map(|x| x * x).collect();\n    println!(\"{:?}\", cuadrados);  // Imprime [1, 4, 9, 16]\n}",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Conceptos Básicos</span>"
    ]
  },
  {
    "objectID": "concepts.html#manejo-de-errores",
    "href": "concepts.html#manejo-de-errores",
    "title": "4  Conceptos Básicos",
    "section": "4.10 Manejo de errores",
    "text": "4.10 Manejo de errores\nEn Rust, el manejo de errores se divide en dos categorías principales: errores recuperables (gestionados con Result) y errores irrecuperables (gestionados con panic!).\nResult: Errores Recuperables\nEl tipo Result es usado cuando una operación puede tener éxito o fallar. Tiene dos variantes:\n\nOk(T): Representa un éxito y contiene un valor.\nErr(E): Representa un error y contiene información del mismo.\n\nEjemplo básico:\nuse std::fs::File;\n\nfn main() {\n    let archivo = File::open(\"archivo.txt\");\n\n    match archivo {\n        Ok(_) =&gt; println!(\"Archivo abierto.\"),\n        Err(e) =&gt; println!(\"Error: {}\", e),\n    }\n}\nTambién puedes usar el operador ? para simplificar el manejo de errores, propagando el error si ocurre:\nfn leer_archivo() -&gt; Result&lt;String, std::io::Error&gt; {\n    let mut archivo = File::open(\"archivo.txt\")?;\n    let mut contenido = String::new();\n    archivo.read_to_string(&mut contenido)?;\n    Ok(contenido)\n}\nOption: Valores Opcionales\nOption es usado para manejar valores que pueden estar presentes o no. Tiene dos variantes:\n\nSome(T): Representa un valor.\nNone: Representa la ausencia de un valor.\n\nEjemplo:\nfn dividir(dividendo: f64, divisor: f64) -&gt; Option&lt;f64&gt; {\n    if divisor == 0.0 {\n        None\n    } else {\n        Some(dividendo / divisor)\n    }\n}\npanic!: Errores Irrecuperables\nCuando ocurre un error grave del que el programa no puede recuperarse, se usa panic! para detener la ejecución:\nfn main() {\n    panic!(\"¡Error grave!\");\n}",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Conceptos Básicos</span>"
    ]
  },
  {
    "objectID": "ownership.html",
    "href": "ownership.html",
    "title": "5  Ownership",
    "section": "",
    "text": "5.1 Definción",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Ownership</span>"
    ]
  },
  {
    "objectID": "ownership.html#referencias-y-préstamos",
    "href": "ownership.html#referencias-y-préstamos",
    "title": "5  Ownership",
    "section": "5.2 Referencias y Préstamos",
    "text": "5.2 Referencias y Préstamos",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Ownership</span>"
    ]
  },
  {
    "objectID": "ownership.html#slices",
    "href": "ownership.html#slices",
    "title": "5  Ownership",
    "section": "5.3 Slices",
    "text": "5.3 Slices",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Ownership</span>"
    ]
  },
  {
    "objectID": "ownership.html#lifetime-annotations",
    "href": "ownership.html#lifetime-annotations",
    "title": "5  Ownership",
    "section": "5.4 Lifetime annotations",
    "text": "5.4 Lifetime annotations\nLas anotaciones de tiempo de vida (lifetimes) son cruciales en Rust y se deberían cubrir al hablar de referencias y préstamos.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Ownership</span>"
    ]
  },
  {
    "objectID": "ownership.html#borrow-checker",
    "href": "ownership.html#borrow-checker",
    "title": "5  Ownership",
    "section": "5.5 Borrow checker",
    "text": "5.5 Borrow checker\nAunque mencionas referencias y préstamos, sería útil dedicar un espacio para explicar en profundidad cómo funciona el borrow checker.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Ownership</span>"
    ]
  },
  {
    "objectID": "struct.html",
    "href": "struct.html",
    "title": "6  Struct",
    "section": "",
    "text": "6.1 Enums\nPara complementar los structs, sería útil explicar los enums en Rust y su uso con match.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Struct</span>"
    ]
  },
  {
    "objectID": "struct.html#traits",
    "href": "struct.html#traits",
    "title": "6  Struct",
    "section": "6.2 Traits",
    "text": "6.2 Traits\nExplicación de cómo los traits permiten una programación orientada a interfaces.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Struct</span>"
    ]
  },
  {
    "objectID": "production.html",
    "href": "production.html",
    "title": "7  Rust en Producción",
    "section": "",
    "text": "7.1 Ejemplo Scraping\nIncluir una subcategoría sobre cómo gestionar concurrencia con Rust usando async/await, ya que el rendimiento concurrente es clave en procesos de scraping.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Rust en Producción</span>"
    ]
  },
  {
    "objectID": "spatial_chapter.html",
    "href": "spatial_chapter.html",
    "title": "8  Rust Espacial",
    "section": "",
    "text": "8.1 Objetos Espaciales",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Rust Espacial</span>"
    ]
  },
  {
    "objectID": "spatial_chapter.html#objetos-espaciales",
    "href": "spatial_chapter.html#objetos-espaciales",
    "title": "8  Rust Espacial",
    "section": "",
    "text": "8.1.1 Vectores\n\n\n8.1.2 Raster\nExplicar cómo manejar objetos espaciales en formato geojson o tiff.\nIntroducir alguna librería como geo o gdal para procesar estos tipos de datos.",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Rust Espacial</span>"
    ]
  },
  {
    "objectID": "spatial_chapter.html#procesos-espaciales",
    "href": "spatial_chapter.html#procesos-espaciales",
    "title": "8  Rust Espacial",
    "section": "8.2 Procesos Espaciales",
    "text": "8.2 Procesos Espaciales\nTransformaciones geográficas: Explicar cómo realizar reproyecciones y transformaciones de coordenadas.\nIntersecciones espaciales: Cómo calcular intersecciones entre objetos espaciales (polígonos, líneas).",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Rust Espacial</span>"
    ]
  },
  {
    "objectID": "spatial_chapter.html#ddbb-espaciales",
    "href": "spatial_chapter.html#ddbb-espaciales",
    "title": "8  Rust Espacial",
    "section": "8.3 DDBB Espaciales",
    "text": "8.3 DDBB Espaciales",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Rust Espacial</span>"
    ]
  },
  {
    "objectID": "spatial_chapter.html#algoritmos",
    "href": "spatial_chapter.html#algoritmos",
    "title": "8  Rust Espacial",
    "section": "8.4 Algoritmos",
    "text": "8.4 Algoritmos\n\n8.4.1 Triangulación de Delaunay\nÚtil para algunos tipos de análisis espacial.\n\n\n8.4.2 Voronoi\nOtro algoritmo que puede complementar la creación de celdas espaciales.\n\n\n8.4.3 Geocoding\n\n\n8.4.4 [[Geohash]]\n\n\n8.4.5 r-tree",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Rust Espacial</span>"
    ]
  },
  {
    "objectID": "functional.html",
    "href": "functional.html",
    "title": "9  Programación Funcional",
    "section": "",
    "text": "Además de una explicación de los conceptos básicos de la programación funcional (map, filter, fold), podrías incluir:\n\nIteradores y closures: Cómo la programación funcional se aplica a operaciones sobre datos espaciales.\nComposición de funciones: Explicar cómo utilizar funciones puras en el contexto espacial.",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Programación Funcional</span>"
    ]
  },
  {
    "objectID": "languages.html",
    "href": "languages.html",
    "title": "10  Otros Lenguajes",
    "section": "",
    "text": "10.1 Rust y R\nextendr - A safe and user-friendly R extension interface using Rust\nextendr_api",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Otros Lenguajes</span>"
    ]
  },
  {
    "objectID": "languages.html#rust-y-python",
    "href": "languages.html#rust-y-python",
    "title": "10  Otros Lenguajes",
    "section": "10.2 Rust y Python",
    "text": "10.2 Rust y Python",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Otros Lenguajes</span>"
    ]
  },
  {
    "objectID": "languages.html#ffi-foreign-function-interface",
    "href": "languages.html#ffi-foreign-function-interface",
    "title": "10  Otros Lenguajes",
    "section": "10.3 FFI (Foreign Function Interface)",
    "text": "10.3 FFI (Foreign Function Interface)\nExplicar cómo Rust se puede integrar con otros lenguajes, especialmente si se piensa en interoperabilidad con Python o R.",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Otros Lenguajes</span>"
    ]
  },
  {
    "objectID": "languages.html#binding-de-librerías",
    "href": "languages.html#binding-de-librerías",
    "title": "10  Otros Lenguajes",
    "section": "10.4 Binding de librerías",
    "text": "10.4 Binding de librerías\nCómo crear bindings en Rust para aprovechar librerías de otros lenguajes para análisis espacial.",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Otros Lenguajes</span>"
    ]
  },
  {
    "objectID": "optimization.html",
    "href": "optimization.html",
    "title": "11  Optimización",
    "section": "",
    "text": "Optimización: Dado que Rust se centra en la eficiencia, sería útil dedicar tiempo a estrategias de optimización específicas para análisis espaciales, como el manejo eficiente de memoria y concurrencia.\nTesting y Benchmarking: En algún punto del libro, podrías agregar una sección sobre cómo probar y medir el rendimiento del código en Rust, especialmente relevante para aplicaciones espaciales que a menudo manejan grandes volúmenes de datos.",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Optimización</span>"
    ]
  }
]