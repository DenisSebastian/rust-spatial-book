# Rust Espacial

## El Potencial de Rust en el Análisis Espacial

Rust está emergiendo como un lenguaje crítico en la infraestructura geoespacial moderna. Herramientas fundamentales como **PyQuante**, partes de **Mapbox**, y motores de bases de datos de alto rendimiento están migrando o escribiéndose en Rust.

¿Por qué este cambio?

1.  **Rendimiento Predecible**: A diferencia de lenguajes con Garbage Collector (como Java, Go o R), Rust ofrece un control de memoria determinista. Esto es crucial cuando procesas terabytes de datos raster o millones de polígonos; evita esas pausas inesperadas que rompen flujos de trabajo en tiempo real.
2.  **Seguridad de Memoria**: El sistema de tipos de Rust previene errores comunes como *null pointers* o *data races* en paralelo. Esto significa que tus herramientas espaciales no solo son rápidas, sino extremadamente robustas y menos propensas a crashear en producción.
3.  **Paralelismo sin Miedo**: El análisis espacial es "embarazosamente paralelo". Rust permite escribir código que usa todos los núcleos de tu CPU de manera segura y sencilla (usando crates como `rayon`), algo que en R o Python a menudo requiere configuraciones complejas de multiprocessing.
4.  **WebAssembly (Wasm)**: Rust compila excelentemente a Wasm, permitiendo ejecutar algoritmos espaciales complejos directamente en el navegador a velocidad nativa, abriendo nuevas fronteras para la visualización web (ej. decks.gl, kepler.gl extensions).

## El Ecosistema Geo-Rust

En R, cuando cargas `library(sf)`, obtienes un paquete completo que maneja lectura de archivos (GDAL), operaciones geométricas (GEOS) y proyecciones (PROJ). En Rust, la filosofía es modular. No hay un solo "paquete maestro", sino una constelación de herramientas especializadas que tú ensamblas según necesites.

Las piezas fundamentales son:

*   **`geo-types`**: Define las primitivas (`Point`, `Polygon`, etc.). Es el vocabulario común.
*   **`geo`**: Algoritmos puros en Rust (área, distancia, intersección).
*   **`gdal`**: Bindings a la librería C++ GDAL (potente corrección, lectura/escritura).
*   **`geos`**: Bindings a la librería C++ GEOS (operaciones topológicas complejas).

::: callout-note
**Analogía**: En R, `sf` es como comprar una navaja suiza. En Rust, tú compras el bisturí, el martillo y la llave inglesa por separado para armar tu propio kit de herramientas optimizado.
:::

## Objetos Espaciales

La estructura mental es idéntica a `sf`, pero la implementación es estricta.

### Puntos y Coordenadas

En R: `st_point(c(x, y))`
En Rust (`geo` crate):

```rust
use geo_types::{Point, Coordinate};

let p = Point::new(10.0, 20.0);
// O usando coordenadas explícitas
let c = Coordinate { x: 10.0, y: 20.0 };
let p2: Point<f64> = c.into();
```

Observa `<f64>`. Rust necesita saber la precisión. `f64` (double precision) es el estándar para coordenadas geográficas.

### Polígonos

Un polígono en Rust es explícito: un anillo exterior (`LineString`) y cero o más anillos interiores (agujeros).

```rust
use geo_types::{Polygon, LineString};

let exterior = LineString::from(vec![
    (0., 0.), (10., 0.), (10., 10.), (0., 10.), (0., 0.)
]);

let poly = Polygon::new(exterior, vec![]);
```

## Operaciones Espaciales

Aquí es donde Rust brilla. Las operaciones en la crate `geo` están implementadas en Rust puro, lo que permite que el compilador las optimice agresivamente (inlining, vectorización).

### Distancia (Haversine vs Euclidiana)

```rust
use geo::prelude::*; // Importa traits como EuclideanDistance

let p1 = Point::new(0.0, 0.0);
let p2 = Point::new(1.0, 1.0);

let dist = p1.euclidean_distance(&p2);
```

### Pipelines de Procesamiento

En R usamos pipes `%>%`. En Rust, usamos encadenamiento de métodos e iteradores. Supongamos que queremos calcular el centroide de mil polígonos:

**En R:**
```r
polygons %>% st_centroid()
```

**En Rust:**
```rust
let centroids: Vec<Point<f64>> = polygons.iter()
    .map(|poly| poly.centroid().unwrap()) // unwrap porque el centroide podría fallar si el poligono es inválido
    .collect();
```
La ventaja aquí es que Rust no crea copias intermedias de toda la lista de polígonos. Procesa uno a uno de manera perezosa (lazy) y solo asigna memoria al final (`collect`).

## Caso Práctico: Geohash

El geohashing es una técnica para codificar coordenadas en strings. Es vital para indexación espacial rápida. En R, las librerías de geohash suelen ser wrappers de C o C++. En Rust, podemos interactuar con los bits directamente.

### El problema del Vecino

Dado un geohash (ej. "u4pruyd"), ¿quién está al norte?

Este problema requiere manipulación de bits y strings. Veamos una implementación simplificada usando una función que podríamos exponer a R.

```rust
use geohash::{neighbor, Direction, decode, encode};

// Wrapper para R (conceptual, usando extendr)
fn get_neighbor(hash_str: String, direction_str: String) -> String {
    let dir = match direction_str.as_str() {
        "n" => Direction::N,
        "s" => Direction::S,
        "e" => Direction::E,
        "w" => Direction::W,
        _ => panic!("Dirección inválida"),
    };

    let coord = decode(&hash_str).expect("Hash inválido");
    // Calcular vecino... (la librería geohash tiene funciones optimizadas para esto)
    let neighbor_hash = neighbor(&hash_str, dir).expect("Error calculando vecino");
    neighbor_hash
}
```

### ¿Por qué Rust es mejor aquí?

1.  **Manejo de Strings**: Rust maneja UTF-8 nativamente pero te obliga a manejar casos borde (¿qué pasa si el string no es válido?).
2.  **Enums**: El `match` para la dirección es exhaustivo. Si olvidas el "Oeste", el código no compila. En R, descubrirías el error en producción cuando un usuario ingrese "w".
3.  **Velocidad**: Calcular millones de vecinos en un bucle sería lentísimo en R. En Rust, es coste cero abstraer esto.

## Ingeniería de Sistemas Espaciales

Para construir sistemas de alto rendimiento:

1.  **Usa `RTree` (crate `rstar`)**: Para búsquedas espaciales (k-NN, intersecciones). Es mucho más rápido que recorrer listas.
2.  **Paralelismo (`rayon`)**: Si tienes que reproyectar 10 millones de puntos, cambia `.iter()` por `.par_iter()`. Rust distribuirá el trabajo en todos tus núcleos automáticamente sin "race conditions".

```rust
use rayon::prelude::*;

let projected: Vec<_> = points.par_iter()
    .map(|p| reproyectar(p))
    .collect();
```
Esto es trivial en Rust, pero complejo y propenso a errores en otros lenguajes.

## Resumen

Rust te da las herramientas para construir la maquinaria pesada del análisis espacial. Mientras R es tu tablero de dibujo, Rust es la línea de ensamblaje automatizada.

## Recursos y Comunidad

El ecosistema de Rust para geoespacial está creciendo rápidamente. Aquí tienes los puntos de entrada esenciales para seguir aprendiendo y encontrar herramientas:

*   **[GeoRust.org](https://georust.org/)**: La página principal de la organización que mantiene las crates `geo`, `geo-types`, `geos`, etc. Aquí encontrarás documentación oficial y guías.
*   **[Awesome GeoRust](https://github.com/pka/awesome-georust)**: Una lista curada (y muy completa) de librerías, aplicaciones y recursos para desarrollo geoespacial en Rust. Es el mejor lugar para buscar si "ya existe una librería para X".
*   **Discord de GeoRust**: La comunidad es muy activa y amigable. Es un excelente lugar para hacer preguntas específicas.

