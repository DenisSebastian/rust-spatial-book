---
subtitle: "Definiendo Comportamiento Compartido"
---

# Traits

Un **Trait** (rasgo) en Rust es un mecanismo para definir comportamiento compartido. Es una forma de decirle al compilador que un tipo de dato tiene cierta funcionalidad que otros tipos también pueden tener.

## Entendiendo el Concepto

### Analogía 1: El Contrato de Trabajo

Imagina que estás contratando personal para una ciudad. Necesitas un "Conductor". No te importa si el candidato es una persona, un robot o un sistema de conducción autónoma; lo único que te importa es que cumpla con el "contrato" de saber conducir (acelerar, frenar, girar).

En Rust:

- Los **Tipos** (Structs/Enums) son los candidatos (ej. `Persona`, `Robot`).
- El **Trait** es el "contrato" o la descripción de la habilidad (ej. `Conducible`).
- La **Implementación** (`impl`) es cómo cada candidato realiza específicamente esa tarea.

### Analogía 2: La Ciudad (Nuestra temática)

Siguiendo la temática de este libro: tienes edificios diferentes, como una `Casa` y un `Hospital`. Son estructuras diferentes con datos diferentes (la casa tiene habitaciones, el hospital tiene camas). Sin embargo, ambos pueden compartir funcionalidades:

- Ambos pueden ser **"Abastecibles"** (recibir agua/luz).
- Ambos pueden ser **"Pintables"**.

Un trait define *qué* se puede hacer (ej. `pintar()`), pero no *cómo* se hace. Pintar una casa pequeña es diferente a pintar un rascacielos, pero ambos son "pintables".

## Comparación con R: S3 Generics

Si vienes del mundo de R, los Traits son conceptualmente muy similares a los **sistemas S3** y sus funciones genéricas.

En R, tienes funciones como `print()`, `plot()` o `summary()`. Estas funciones se comportan de manera diferente según el objeto que les pases.

- Si haces `plot(mis_datos_geoespaciales)`, R busca internamente `plot.sf` (si usas la librería `sf`).
- Si haces `plot(mi_modelo_lineal)`, R busca `plot.lm`.

Esto es **Polimorfismo**.

#### Ejemplo en R

```r
# Definimos dos "clases" diferentes
rectangulo <- list(ancho = 10, alto = 20)
class(rectangulo) <- "Rectangulo"

circulo <- list(radio = 5)
class(circulo) <- "Circulo"

# Definimos una función genérica "area" (Esto sería el Trait en Rust)
area <- function(x) {
  UseMethod("area")
}

# Implementamos para Rectangulo
area.Rectangulo <- function(x) {
  x$ancho * x$alto
}

# Implementamos para Circulo
area.Circulo <- function(x) {
  pi * x$radio^2
}

# La función area() funciona para ambos, aunque son distintos
print(area(rectangulo)) 
print(area(circulo))
```

Rust hace esto mismo, pero el compilador verifica que *realmente* hayas implementado la función `area` para esos tipos antes de dejarte ejecutar el código, evitando errores en tiempo de ejecución.

## Definición y Uso en Rust

Volvamos a nuestra ciudad. Definamos un trait `Habilidad` que permita a los edificios realizar una acción.

```rust
// 1. Definimos el Trait (El contrato)
// Cualquier tipo que quiera tener "Habilidad" DEBE tener un método activar_funcion
trait Habilidad {
    fn activar_funcion(&self) -> String;
}

// Structs de nuestra ciudad
struct Edificio {
    nombre: String,
    pisos: u32,
}

struct Parque {
    nombre: String,
    area_verde: bool,
}

// 2. Implementamos Habilidad para Edificio
impl Habilidad for Edificio {
    fn activar_funcion(&self) -> String {
        format!("El edificio {} enciende sus luces.", self.nombre)
    }
}

// 3. Implementamos Habilidad para Parque
impl Habilidad for Parque {
    fn activar_funcion(&self) -> String {
        if self.area_verde {
            "El parque abre sus puertas y riega el pasto.".to_string()
        } else {
            "El parque abre sus puertas.".to_string()
        }
    }
}

fn main() {
    let torre = Edificio { nombre: "Torre Central".to_string(), pisos: 20 };
    let plaza = Parque { nombre: "Plaza Mayor".to_string(), area_verde: true };

    // Ambos tipos distintos comparten el mismo comportamiento
    println!("{}", torre.activar_funcion());
    println!("{}", plaza.activar_funcion());
}
```

### ¿Por qué son útiles?

La magia ocurre cuando escribes funciones que aceptan **Traits** en lugar de tipos concretos.

```rust
// Esta función acepta CUALQUIER cosa que tenga la Habilidad
// No le importa si es un Edificio, un Parque o un Coche.
fn ejecutar_accion_ciudadana(elemento: &impl Habilidad) {
    println!("Evento en la ciudad: {}", elemento.activar_funcion());
}
```

Esto permite escribir código extremadamente flexible y reutilizable (`Generic Programming`).

## Traits Derivables

En Rust, verás muy seguido esto encima de los structs:

```rust
#[derive(Debug, Clone, PartialEq)]
struct Casa {
    numero: u32
}
```

`Debug`, `Clone` y `PartialEq` son Traits.
- `Debug`: Permite imprimir el struct con `{:?}` (como el `print()` básico de R).
- `Clone`: Permite hacer copias del objeto.
- `PartialEq`: Permite comparar si `casa1 == casa2`.

La instrucción `#[derive(...)]` le dice al compilador: "Por favor, escribe la implementación por defecto de estos traits por mí, no quiero escribirla manualmente". Es un ahorro de tiempo enorme para comportamientos estándar.
