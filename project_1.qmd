---
title: "Tu primera estructura espacial"
subtitle: "De la teor√≠a a la pr√°ctica: Implementando Pol√≠gonos"
---

# Introducci√≥n

¬°Bienvenido a tu primer proyecto pr√°ctico! Hasta ahora hemos hablado de edificios, robots y ciudades en abstracto. Ahora nos pondremos el casco de ingenieros y construiremos c√≥digo real que podr√≠as usar (y de hecho, se usa de forma muy similar) en herramientas profesionales de GIS.

En este cap√≠tulo, vamos a construir desde cero una estructura para manejar **Pol√≠gonos**. No usaremos librer√≠as externas m√°gicas todav√≠a (como `geo-types`), porque quiero que *entiendas* c√≥mo funcionan por dentro.

Nuestro objetivo hoy es:

1.  Crear un objeto `Point` (Punto).
2.  Crear un objeto `Polygon` (Pol√≠gono) compuesto de puntos.
3.  Calcular su √°rea matem√°ticamente (implementando m√©todos).
4.  Definir un comportamiento est√°ndar (Trait) para geometr√≠as.
5.  Asegurarnos de que el pol√≠gono sea v√°lido (Validaci√≥n).
6.  Prepararlo para guardarlo en una base de datos (Persistencia).

¬°Manos a la obra!

## 1. El √Åtomo Espacial: El Punto (`Point`)

Todo empieza con un punto. En un plano 2D, un punto no es m√°s que una coordenada X y una Y.

Vamos a definir nuestro `struct Point`.

```rust
// Derivamos Debug para poder imprimirlo en la consola.
// Derivamos Clone y Copy porque un punto es muy ligero (solo dos n√∫meros),
// y es m√°s f√°cil copiarlo que pasarlo por referencia constantemente.
#[derive(Debug, Clone, Copy)]
pub struct Point {
    pub x: f64,
    pub y: f64,
}

impl Point {
    // Un "constructor" simple
    pub fn new(x: f64, y: f64) -> Self {
        Point { x, y }
    }
}
```

::: {.callout-note}
**¬øPor qu√© `f64`?**
En computaci√≥n cient√≠fica y geoespacial, usamos `f64` (flotante de doble precisi√≥n) para minimizar los errores de redondeo. Un `f32` (precisi√≥n simple) podr√≠a perder precisi√≥n si trabajas con coordenadas geogr√°ficas muy grandes (como UTM).
:::

## 2. Construyendo Geometr√≠as: El Pol√≠gono (`Polygon`)

Un pol√≠gono simple se puede definir como una lista ordenada de puntos que forman un anillo exterior.

```rust
#[derive(Debug, Clone)]
pub struct Polygon {
    // Usamos Vec (Vector) porque el pol√≠gono puede tener 3, 4, 100 o mil puntos.
    // Es una lista din√°mica.
    pub exterior: Vec<Point>,
}
```

F√≠jate que `Polygon` tiene `Vec<Point>`. Aqu√≠ `Polygon` es el "due√±o" de esos puntos.

## 3. Dando Vida: C√°lculo de √Årea (`impl`)

Un pol√≠gono que solo guarda puntos es aburrido. Queremos saber cu√°n grande es. Vamos a implementar el **Algoritmo del Cord√≥n (Shoelace Formula)** para calcular el √°rea.

No te asustes por la matem√°tica, el c√≥digo es sorprendentemente limpio en Rust.

```rust
impl Polygon {
    // Constructor b√°sico
    pub fn new(points: Vec<Point>) -> Self {
        Polygon { exterior: points }
    }

    // M√©todo para calcular el √°rea
    // &self significa: "Me leo a m√≠ mismo, pero no me modifico"
    pub fn area(&self) -> f64 {
        let points = &self.exterior;
        let n = points.len();
        
        if n < 3 {
            return 0.0; // No es un pol√≠gono si tiene menos de 3 puntos
        }

        let mut sum = 0.0;

        for i in 0..n {
            // Conectamos el punto actual (i) con el siguiente (j)
            // Si i es el √∫ltimo, j debe ser el primero (el √≠ndice 0)
            let j = (i + 1) % n; 
            
            sum += points[i].x * points[j].y;
            sum -= points[j].x * points[i].y;
        }

        (sum / 2.0).abs()
    }
}
```

### Prob√©moslo

Puedes copiar y pegar esto en tu `main.rs` para probarlo:

```rust
fn main() {
    // Creamos un cuadrado 10x10
    let puntos = vec![
        Point::new(0.0, 0.0),
        Point::new(10.0, 0.0),
        Point::new(10.0, 10.0),
        Point::new(0.0, 10.0),
        Point::new(0.0, 0.0), // Cerramos el ciclo
    ];

    let mi_poligono = Polygon::new(puntos);

    println!("√Årea del pol√≠gono: {}", mi_poligono.area());
}
```

Si corres esto, deber√≠as ver `√Årea del pol√≠gono: 100`.

## 4. El Contrato Espacial (`trait`)

Ahora imagina que tambi√©n tenemos `Circle` (C√≠rculo) o `LineString` (L√≠nea). Todos tienen √°rea (bueno, la l√≠nea tiene √°rea 0, pero se entiende).

Para tratar a todas las geometr√≠as por igual, definimos un **Trait**.

```rust
pub trait SpatialObject {
    // Cualquier objeto espacial debe saber decirme su √°rea
    fn area(&self) -> f64;
    
    // Y digamos que tambi√©n queremos saber su tipo como texto
    fn geometry_type(&self) -> &str;
}
```

Ahora, implementamos este "contrato" para nuestro Pol√≠gono:

```rust
impl SpatialObject for Polygon {
    fn area(&self) -> f64 {
        // Reusamos la l√≥gica que ya escribimos arriba por conveniencia
        self.area()
    }

    fn geometry_type(&self) -> &str {
        "Polygon"
    }
}
```

Esto nos permite escribir funciones gen√©ricas poderosas:

### Prob√©moslo en `main`

Para que esto funcione, colocamos la funci√≥n gen√©rica y la llamamos desde el `main`:

```rust
fn main() {
    let puntos = vec![
        Point::new(0.0, 0.0), Point::new(4.0, 0.0),
        Point::new(4.0, 4.0), Point::new(0.0, 4.0),
        Point::new(0.0, 0.0),
    ];
    
    // Creamos el pol√≠gono
    let cuadrado = Polygon::new(puntos);

    // ¬°Aqu√≠ est√° la magia!
    // Pasamos el pol√≠gono a una funci√≥n que SOLO espera un "SpatialObject"
    reporte_espacial(&cuadrado);
}

// Esta funci√≥n acepta CUALQUIER cosa que cumpla el contrato SpatialObject
fn reporte_espacial(objeto: &impl SpatialObject) {
    println!("--- REPORTE ---");
    println!("Tipo de Geometr√≠a: {}", objeto.geometry_type());
    println!("Medida Espacial:   {}", objeto.area());
    println!("-----------------");
}
```

## 5. Validaci√≥n y Robustez: Evitando Geometr√≠as Imposibles

En el mundo real, los datos vienen sucios. Un pol√≠gono podr√≠a tener solo 2 puntos (una l√≠nea) o no estar cerrado (el √∫ltimo punto no es igual al primero).

Rust nos invita a manejar esto expl√≠citamente.

Mejoremos nuestro constructor `new` para que sea inteligente. En lugar de devolver un `Polygon` "a la fuerza", devolver√° un `Option<Polygon>`.

- `Some(Polygon)` si todo est√° bien.
- `None` si los datos son inv√°lidos.

```rust
impl Polygon {
    // Ahora devolvemos Option<Self>
    pub fn new_checked(points: Vec<Point>) -> Option<Self> {
        if points.len() < 4 {
            // Un pol√≠gono cerrado necesita al menos 3 v√©rtices + 1 de cierre = 4 puntos
            return None; 
        }

        // Verificamos si est√° cerrado (primero == √∫ltimo)
        // Ojo: comparar f64 con == es peligroso por decimales, pero para este ejemplo sirve.
        let first = points.first().unwrap();
        let last = points.last().unwrap();

        // Peque√±o truco para comparar float: la diferencia debe ser muy peque√±a
        if (first.x - last.x).abs() > 1e-6 || (first.y - last.y).abs() > 1e-6 {
             return None; // No est√° cerrado
        }

        Some(Polygon { exterior: points })
    }
}
```

Ahora el usuario est√° obligado a manejar el error:

### Prob√©moslo en `main`

Intenta romper tu propio c√≥digo pasando datos incorrectos:

```rust
fn main() {
    // Caso 1: Puntos insuficientes (solo una l√≠nea)
    let puntos_malos = vec![
        Point::new(0.0, 0.0), 
        Point::new(10.0, 10.0)
    ];

    println!("Intentando crear pol√≠gono inv√°lido...");
    let resultado = Polygon::new_checked(puntos_malos);

    match resultado {
        Some(p) => println!("¬°Creado! √Årea: {}", p.area()),
        None => println!(">> Error: No se pudo crear el pol√≠gono. Datos inv√°lidos."),
    }

    // Caso 2: Datos correctos
    let puntos_buenos = vec![
        Point::new(0.0, 0.0), Point::new(5.0, 0.0),
        Point::new(5.0, 5.0), Point::new(0.0, 5.0),
        Point::new(0.0, 0.0) // Cerrado
    ];
    
    println!("\nIntentando crear pol√≠gono v√°lido...");
    if let Some(poly) = Polygon::new_checked(puntos_buenos) {
        println!(">> ¬°√âxito! Pol√≠gono creado correctamente.");
    }
}
```

## 6. Integraci√≥n con Base de Datos (Simulaci√≥n)

Finalmente, queremos guardar esto. Digamos que usamos una base de datos que acepta formato WKT (Well-Known Text), como `POLYGON((0 0, 10 0, 10 10, 0 10, 0 0))`.

Podemos agregar un m√©todo a nuestro Trait o al Struct para convertirlo a WKT.

```rust
impl Polygon {
    pub fn to_wkt(&self) -> String {
        let coords: Vec<String> = self.exterior
            .iter()
            .map(|p| format!("{} {}", p.x, p.y)) // "x y"
            .collect();
            
        // Unimos con comas
        let coords_str = coords.join(", ");
        
        format!("POLYGON(({}))", coords_str)
    }
}
```

### El Flujo Completo

Imagina que recibes datos crudos (quiz√°s de un CSV), los validas y los preparas para insertar en DuckDB:

Juntemos todo en un ejemplo final que simula un peque√±o motor de procesamiento de datos.

```rust
fn main() {
    // Imaginemos que esto viene de leer un archivo CSV
    let lote_de_datos = vec![
        // Pol√≠gono 1: V√°lido (Tri√°ngulo)
        vec![
            Point::new(0.0, 0.0), Point::new(10.0, 0.0), 
            Point::new(5.0, 10.0), Point::new(0.0, 0.0)
        ],
        // Pol√≠gono 2: Inv√°lido (L√≠nea)
        vec![
            Point::new(0.0, 0.0), Point::new(10.0, 10.0)
        ],
    ];

    println!("Iniciando procesamiento por lotes...\n");

    for (i, datos) in lote_de_datos.iter().enumerate() {
        println!("Procesando registro #{}...", i + 1);
        procesar_datos_entrada(datos.clone());
        println!("---");
    }
}

fn procesar_datos_entrada(datos_crudos: Vec<Point>) {
    // 1. Intentar crear el pol√≠gono (Validaci√≥n)
    // El 'if let' es una forma corta y elegante de hacer match solo si es Some
    if let Some(poly) = Polygon::new_checked(datos_crudos) {
        
        // 2. Calcular propiedades (C√≥mputo)
        let area = poly.area();
        println!("  ‚úÖ Geometr√≠a v√°lida detectada.");
        println!("  üìä √Årea calculada: {:.2}", area);

        // 3. Serializar para DB (Persistencia)
        let wkt = poly.to_wkt();
        println!("  üíæ Guardando en DB: INSERT INTO geom_table VALUES ('{}');", wkt);
        
    } else {
        println!("  ‚ùå Error: Geometr√≠a corrupta o inv√°lida. Registro descartado.");
    }
}
```

## Conclusi√≥n

Has creado una estructura espacial completa desde cero.

1.  Definiste la **Estructura** de datos (`struct`).
2.  Implementaste **Comportamiento** propio (`impl`).
3.  Te adheriste a un **Contrato** est√°ndar (`trait`).
4.  Agregaste **Validaci√≥n** para robustez (`Option`).
5.  Preparaste la **Serializaci√≥n** para transporte o base de datos.

Esta es la base de todo sistema GIS moderno. Rust solo te pide que seas expl√≠cito con estas reglas desde el principio, lo que te ahorra miles de horas de depuraci√≥n en el futuro.