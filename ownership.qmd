# Ownership y Borrowing


El sistema de **Ownership** (propiedad) y **Borrowing** (pr√©stamo) es el coraz√≥n de Rust y lo que garantiza su **seguridad en memoria** sin necesidad de un recolector de basura. Aunque puede sonar complejo al principio, usando analog√≠as simples podemos descomponerlo en conceptos f√°ciles de entender.

## Definci√≥n

El ownership es un conjunto de reglas que definen c√≥mo un programa de Rust administra la memoria. Todos los programas tienen que administrar la forma en que usan la memoria de un computador mientras se ejecutan. Algunos lenguajes tienen recolecci√≥n de basura que busca regularmente la memoria que ya no se usa mientras el programa se ejecuta; en otros lenguajes, el programador debe asignar y liberar la memoria expl√≠citamente. Rust usa un tercer enfoque: la memoria se administra a trav√©s de un sistema de ownership con un conjunto de reglas que el compilador verifica. Si alguna de las reglas se viola, el programa no se compilar√°. Ninguna de las caracter√≠sticas del ownership ralentizar√° su programa mientras se ejecuta.


## Ownership

En Rust, cada valor tiene un **due√±o**. Piensa en una mochila que contiene un objeto (datos). Solo **una persona** puede ser due√±a de esa mochila en un momento dado.

**Reglas de Ownership**

1. Cada valor en Rust tiene un **due√±o √∫nico**.
2. Cuando el due√±o "deja de existir" (sale de su alcance), los datos se eliminan autom√°ticamente (**drop**).


::: {.callout-tip}
## üß≥ Analog√≠a "El Due√±o de la Mochila"

Imagina que tienes una mochila que representa la memoria en Rust. Solo t√∫ puedes poseer esa mochila. Si decides pasar la mochila a otra persona, ya no puedes usarla, porque ahora esa persona es la nueva due√±a.
:::

Ejemplo en C√≥digo

```rust
fn main() {
    let mochila = String::from("Mis pertenencias"); // La mochila tiene un due√±o
    let nueva_mochila = mochila; // La propiedad se transfiere
    // println!("{}", mochila); // Error: "mochila" ya no es v√°lida.
    println!("{}", nueva_mochila); // Ahora "nueva_mochila" es el due√±o.
}
```

## Borrowing

A veces, en lugar de transferir completamente la propiedad, necesitas **prestar** tu mochila a alguien m√°s. En Rust, esto se logra usando **referencias**.

**Reglas de Borrowing**

1. Puedes **prestar tu mochila** (crear una referencia) sin transferir la propiedad.
2. Hay dos tipos de pr√©stamos:
   - **Pr√©stamos inmutables** (`&`): Puedes prestar tu mochila para mirarla, pero nadie puede modificarla.
   - **Pr√©stamos mutables** (`&mut`): Puedes prestar tu mochila para que la modifiquen, pero solo a una persona a la vez.


::: {.callout-tip}
## üß≥ Analog√≠a: "Pr√©stamos Temporales"

- **Pr√©stamo inmutable**: Prestas tu mochila a un amigo para que la mire, pero no puede tocar nada dentro.
- **Pr√©stamo mutable**: Prestas tu mochila a un amigo, pero le adviertes que nadie m√°s puede tocarla mientras √©l la tenga.
:::



Ejemplo en C√≥digo

```rust
fn main() {
    let mochila = String::from("Mis pertenencias");
    
    // Pr√©stamo inmutable
    let referencia = &mochila;
    println!("{}", referencia); // Puedo mirar el contenido.
    println!("{}", mochila); // Y todav√≠a soy el due√±o.

    // Pr√©stamo mutable
    let mut mochila_mutable = String::from("Mochila vieja");
    let referencia_mutable = &mut mochila_mutable;
    referencia_mutable.push_str(" actualizada");
    println!("{}", referencia_mutable); // Mochila modificada.
}
```


## Lifetimes

Cuando prestas algo, el tiempo que alguien lo tiene debe ser **claro** para evitar conflictos. En Rust, esto se maneja con las **lifetimes**.

**Reglas B√°sicas**
1. Un pr√©stamo no puede durar m√°s que el due√±o original.
2. El compilador verifica que todos los pr√©stamos sean seguros.


::: {.callout-tip}
## üß≥ Analog√≠a: "Duraci√≥n del Pr√©stamo"

Imagina que tu amigo tiene que devolverte la mochila antes de que t√∫ te vayas de la reuni√≥n, o ambos estar√°n en problemas.
:::




Ejemplo en C√≥digo

```rust
fn main() {
    let mochila = String::from("Mis cosas");
    let referencia = &mochila; // El pr√©stamo es v√°lido aqu√≠.
    println!("{}", referencia); // Todav√≠a puedo usar la referencia.

    // Cuando la mochila "muere", la referencia tambi√©n deja de ser v√°lida.
}
```

## Resumen Visual


| Concepto          | Analog√≠a                             | C√≥digo                   |
|--------------------|--------------------------------------|--------------------------|
| Ownership          | Mochila transferida a otro due√±o.   | `let b = a;`            |
| Borrowing          | Mochila prestada temporalmente.     | `let b = &a;`           |
| Borrowing mutable  | Mochila prestada para modificarla.  | `let b = &mut a;`       |
| Lifetimes          | Tiempo l√≠mite del pr√©stamo.         | `let r = &x;`           |



## Slices

En Rust, los **slices** son una forma especial de pr√©stamo, que permite acceder a una parte de una colecci√≥n (como un array o un `String`) sin transferir la propiedad ni copiar los datos.

::: {.callout-tip}
## üß≥ Analog√≠a: "Un vistazo a la mochila"

Imagina que est√°s en una sala de reuniones con mochilas (que representan los datos):
1. El **inspector** verifica que solo haya **un due√±o por mochila**.
2. Si alguien toma prestada una mochila (una referencia):
   - Si es un pr√©stamo inmutable, otras personas pueden mirar, pero nadie puede modificar.
   - Si es un pr√©stamo mutable, nadie m√°s puede mirar ni tocar hasta que se devuelva.
3. Al final, el inspector revisa que nadie intente usar una mochila que ya no est√° en la sala (lifetime expirado).

:::

- Un **slice inmutable** es como prestar tu mochila abierta y decir: ‚ÄúMira solo lo que est√° en el bolsillo lateral‚Äù, pero no puedes tocar ni cambiar nada.
- Un **slice mutable** es como prestar el bolsillo lateral y permitir que lo reorganicen, pero sin tocar el resto de la mochila.

Ejemplo: Slice Inmutable

```rust
fn main() {
    let array = [1, 2, 3, 4, 5];
    let slice = &array[1..4]; // Slice inmutable que incluye los elementos 2, 3, 4
    println!("{:?}", slice); // Imprime: [2, 3, 4]
    println!("{:?}", array); // La colecci√≥n original sigue siendo accesible
}
```

Ejemplo: Slice Mutable

```rust
fn main() {
    let mut array = [1, 2, 3, 4, 5];
    let slice = &mut array[1..4]; // Slice mutable
    slice[0] = 10; // Modifico solo el primer elemento del slice
    println!("{:?}", slice); // Imprime: [10, 3, 4]
    println!("{:?}", array); // Imprime: [1, 10, 3, 4, 5] (el array original tambi√©n cambia)
}
```

**Relaci√≥n con Ownership y Borrowing**

Los slices son **referencias** (`&` o `&mut`), lo que significa que respetan todas las reglas de **ownership** y **borrowing**:

1. **Ownership**:
   - El slice nunca toma posesi√≥n de los datos; solo los presta temporalmente.

2. **Borrowing**:
   - Siguen las mismas reglas que las referencias:
     - Un slice mutable (`&mut`) y otro slice o referencia no pueden coexistir.
     - Los slices no pueden durar m√°s que la colecci√≥n original de la que provienen.

Ejemplo: Regla de Borrowing con Slices

```rust
fn main() {
    let mut array = [1, 2, 3, 4, 5];
    let slice = &array[1..4]; // Pr√©stamo inmutable
    // let mutable_slice = &mut array[2..4]; // Error: No puedes mutar mientras hay un pr√©stamo inmutable activo
    println!("{:?}", slice);
}
```

Los slices son herramientas poderosas para acceder a partes de datos sin necesidad de copiar ni transferir propiedad, lo que los hace eficientes y seguros. Son una extensi√≥n directa del sistema de **ownership y borrowing**, y demuestran c√≥mo Rust optimiza el manejo de datos respetando la seguridad de memoria.



## Borrow Checker

El **Borrow Checker** es una herramienta interna del compilador de Rust que garantiza que todas las reglas de **ownership**, **borrowing** y **lifetimes** se respeten en tiempo de compilaci√≥n. Esto asegura que los programas sean seguros en memoria y libres de errores comunes como referencias colgantes o conflictos de pr√©stamos.


::: {.callout-tip}
## üß≥ Analog√≠a: "El inspector en la sala de reuniones"

Imagina que est√°s en una sala de reuniones con mochilas (que representan los datos):

1. El **inspector** verifica que solo haya **un due√±o por mochila**.
2. Si alguien toma prestada una mochila (una referencia):
   - Si es un pr√©stamo inmutable, otras personas pueden mirar, pero nadie puede modificar.
   - Si es un pr√©stamo mutable, nadie m√°s puede mirar ni tocar hasta que se devuelva.
3. Al final, el inspector revisa que nadie intente usar una mochila que ya no est√° en la sala (lifetime expirado).
:::




**¬øQu√© valida el Borrow Checker?**

1. **Ownership**:
   - Cada valor tiene un √∫nico due√±o.
   - Los valores se liberan autom√°ticamente cuando su due√±o sale de alcance.
2. **Borrowing**:
   - Permite m√∫ltiples pr√©stamos inmutables o un √∫nico pr√©stamo mutable, pero no ambos a la vez.
3. **Lifetimes**:
   - Las referencias no deben vivir m√°s tiempo que el valor original.

Ejemplo de Borrow Checker en Acci√≥n

```rust
fn main() {
    let mut mochila = String::from("Mis cosas");

    // Pr√©stamos inmutables
    let prestamo1 = &mochila; 
    let prestamo2 = &mochila; 
    println!("{}, {}", prestamo1, prestamo2); // Esto es v√°lido

    // Pr√©stamo mutable conflictivo
    // let prestamo_mutable = &mut mochila; 
    // Error: No puedes tener pr√©stamos mutables e inmutables al mismo tiempo
}
```

Ejemplo de Error con Borrow Checker

```rust
fn main() {
    let referencia;
    {
        let mochila = String::from("Temporal");
        referencia = &mochila; // Error: La referencia vive m√°s que el valor original
    }
    // println!("{}", referencia); // El Borrow Checker impide este uso.
}
```

El **Borrow Checker** act√∫a como un inspector que asegura que:

- Los datos sean usados de manera segura y eficiente.
- No haya referencias colgantes ni conflictos de acceso.

Gracias al Borrow Checker, Rust garantiza seguridad de memoria en tiempo de compilaci√≥n, haciendo innecesario un recolector de basura y optimizando el rendimiento del programa.



## Errores Comunes y C√≥mo Evitarlos


### Uso despu√©s de transferencia

- **Error**: Usar un valor despu√©s de transferir su propiedad.
- **Ejemplo**:

```rust
  fn main() {
      let mochila = String::from("Mis pertenencias");
      let nueva_mochila = mochila; // Propiedad transferida
      // println!("{}", mochila); // Error: "mochila" ya no es v√°lida.
  }
```
- **Soluci√≥n**: Revisa si has movido el valor o usa referencias si necesitas acceder a √©l.


### Conflictos en pr√©stamos mutables

- **Error**: Prestar un valor de forma mutable mientras tienes pr√©stamos inmutables activos.
- **Ejemplo**:

```rust
  fn main() {
      let mut mochila = String::from("Mis cosas");
      let referencia1 = &mochila; // Pr√©stamo inmutable
      let referencia2 = &mut mochila; // Error: No puedes prestar de forma mutable mientras hay un pr√©stamo inmutable
  }
```
- **Soluci√≥n**: Aseg√∫rate de que no hay m√∫ltiples accesos conflictivos al mismo tiempo.


### Referencias a datos no v√°lidos

- **Error**: Crear una referencia que vive m√°s que el valor original.
- **Ejemplo**:

```rust
  fn main() {
      let referencia;
      {
          let mochila = String::from("Temporal");
          referencia = &mochila; // Error: La referencia vive m√°s que el valor original
      }
      // println!("{}", referencia); // No v√°lido
  }
```

- **Soluci√≥n**: Aseg√∫rate de que los pr√©stamos no duren m√°s que el valor original.
