{"title":"Conceptos Básicos","markdown":{"headingText":"Conceptos Básicos","containsRefs":false,"markdown":"\nEste capítulo cubre conceptos que aparecen en casi todos los lenguajes de programación y cómo funcionan en Rust. Muchos lenguajes de programación tienen mucho en común en su núcleo. Ninguno de los conceptos presentados en este capítulo son únicos de Rust, pero los discutiremos en el contexto de Rust y explicaremos las convenciones alrededor de su uso.\n\nEspecíficamente, aprenderás sobre variables, tipos básicos, funciones, comentarios y flujo de control. Estas bases estarán en todos los programas de Rust, y aprenderlas temprano te dará un núcleo fuerte para comenzar.\n\n## Variables y Mutabilidad\n\nEn Rust, las variables son inmutables por defecto, lo que promueve la seguridad y la concurrencia. Esto significa que una vez que se asigna un valor a una variable, no puede ser cambiado. Sin embargo, Rust permite optar por variables mutables si es necesario.\n\nPor ejemplo, el siguiente código da un error porque intenta reasignar un valor a la variable x sin hacerla mutable:\n\n``` rust\n\nfn main() {\n    let x = 5;\n    println!(\"El valor de x es: {x}\");\n    x = 6; // Error: no se puede asignar dos veces a una variable inmutable.\n}\n```\n\nEste error es útil porque garantiza que no modifiquemos accidentalmente variables que deben permanecer inmutables, lo que puede causar errores difíciles de detectar.\n\nSi necesitas cambiar el valor de una variable, puedes hacerla mutable usando `mut`:\n\n``` rust\n\nfn main() {\n    let mut x = 5;\n    println!(\"El valor de x es: {x}\");\n    x = 6;\n    println!(\"El nuevo valor de x es: {x}\");\n}\n\n```\n\nCon `mut`, el valor de `x` puede cambiar de 5 a 6. La mutabilidad es útil en muchos casos, pero usar variables inmutables puede ayudar a evitar errores y hacer que tu código sea más fácil de entender.\n\n## Tipos de datos básicos\n\nRust es un lenguaje fuertemente tipado, lo que significa que cada valor debe tener un tipo específico. Estos tipos se dividen principalmente en dos categorías: tipos escalares y tipos compuestos. En esta sección, nos centraremos en los tipos escalares, que representan un valor único.\n\n### Tipos Escalares\n\nLos tipos escalares incluyen enteros, números de coma flotante, caracteres y booleanos. A continuación, se presenta una tabla con los principales tipos de datos y ejemplos de sus valores literales:\n\n| Tipo | Sintaxis | Ejemplos |\n|--------------------|------------------------------|----------------------|\n| Enteros con signo | i8, i16, i32, i64, i128, isize | -10, 0, 1_000, 123_i64 |\n| Enteros sin signo | u8, u16, u32, u64, u128, usize | 0, 123, 10_u16 |\n| Números de coma flotante | f32, f64 | 3.14, -10.0e20, 2_f32 |\n| Valores escalares Unicode | char | 'a', 'α', '∞' |\n| Booleanos | bool | true, false |\n\n**Ancho de los Tipos**\n\nCada tipo tiene un tamaño específico en memoria:\n\n-   `iN`, `uN`, y `fN` tienen un ancho de N bits.\n-   `isize` y `usize` tienen el ancho de un puntero, lo que depende de la arquitectura del sistema (generalmente 32 o 64 bits).\n-   `char` tiene un tamaño de 32 bits, lo que permite representar cualquier carácter Unicode.\n-   `bool` ocupa 8 bits de espacio en memoria.\n\nEjemplo de Uso\n\nPodemos ver cómo se utilizan estos tipos de datos en un programa simple:\n\n``` rust\nfn main() {\n    let entero_con_signo: i32 = -500;\n    let entero_sin_signo: u32 = 300;\n    let flotante: f64 = 3.1415;\n    let caracter: char = '∞';\n    let booleano: bool = true;\n    \n    println!(\"Entero con signo: {}\", entero_con_signo);\n    println!(\"Entero sin signo: {}\", entero_sin_signo);\n    println!(\"Flotante: {}\", flotante);\n    println!(\"Carácter: {}\", caracter);\n    println!(\"Booleano: {}\", booleano);\n}\n```\n\nEste ejemplo muestra cómo declarar y utilizar los diferentes tipos de datos en Rust, cada uno con su correspondiente tipo y valor literal.\n\n## Control de Flujos\n\nEn Rust, el control de flujos permite dirigir la ejecución del programa basándose en condiciones y repeticiones. Rust ofrece varias estructuras para controlar el flujo de la ejecución del código, como if para condiciones y bucles para repetir bloques de código.\n\nAquí tienes una tabla con las operaciones lógicas y su sintaxis en Rust, qué se utilizan en control de flujos:\n\n| **Operación** | **Símbolo** | **Descripción** | **Ejemplo** |\n|---------------|---------------|----------------------------|---------------|\n| **AND lógico** | `&&` | Verdadero si ambas expresiones son verdaderas | `true && false` (devuelve `false`) |\n| **OR lógico** | `||` | Verdadero si al menos una expresión es verdadera | `true || false` (devuelve `true`) |\n| **NOT lógico** | `!` | Invierte el valor de verdad de una expresión | `!true` (devuelve `false`) |\n| **Igualdad** | `==` | Verdadero si ambas expresiones son iguales | `5 == 5` (devuelve `true`) |\n| **Desigualdad** | `!=` | Verdadero si ambas expresiones no son iguales | `5 != 6` (devuelve `true`) |\n| **Mayor que** | `>` | Verdadero si la primera expresión es mayor que la segunda | `6 > 3` (devuelve `true`) |\n| **Menor que** | `<` | Verdadero si la primera expresión es menor que la segunda | `3 < 5` (devuelve `true`) |\n| **Mayor o igual que** | `>=` | Verdadero si la primera expresión es mayor o igual a la segunda | `5 >= 5` (devuelve `true`) |\n| **Menor o igual que** | `<=` | Verdadero si la primera expresión es menor o igual a la segunda | `3 <= 4` (devuelve `true`) |\n\n### Expresión if\n\nEn Rust, la expresión if evalúa una condición booleana y ejecuta un bloque de código dependiendo de si la condición es verdadera (true) o falsa (false). A diferencia de otros lenguajes, if en Rust es una expresión, lo que significa que puede devolver un valor.\n\n``` rust\nfn main() {\n    let numero = 5;\n\n    if numero > 3 {\n        println!(\"El número es mayor que 3.\");\n    } else {\n        println!(\"El número es 3 o menor.\");\n    }\n}\n```\n\nTambién se puede usar la expresión if para asignar valores:\n\n``` rust\nlet condicion = true;\nlet numero = if condicion { 5 } else { 6 };\n```\n\nEs importante recordar que las ramas del if deben devolver el mismo tipo.\n\n### Bucles\n\nRust proporciona tres tipos de bucles: `loop`, `while`, y `for`.\n\n`loop`\n\n:   Ejecuta un bloque de código indefinidamente hasta que se detenga explícitamente con una instrucción break.\n\n``` rust\nfn main() {\n    let mut contador = 0;\n\n    loop {\n        contador += 1;\n        println!(\"Contador: {contador}\");\n\n        if contador == 5 {\n            break;  // Detiene el bucle cuando contador es 5\n        }\n    }\n}\n```\n\n`while`\n\n:   Ejecuta un bloque de código mientras una condición booleana sea verdadera.\n\n``` rust\nfn main() {\n    let mut numero = 3;\n\n    while numero != 0 {\n        println!(\"{numero}\");\n        numero -= 1;\n    }\n}\n```\n\n`for`\n\n:   Recorre elementos de una colección o un rango.\n\n``` rust\nfn main() {\n    for numero in 1..4 {\n        println!(\"{numero}\");\n    }\n}\n```\n\n### break y continue\n\n`break`: Termina el bucle inmediatamente.\n\n`continue`: Salta al siguiente ciclo del bucle sin ejecutar el resto del bloque actual.\n\nEjemplo combinando ambos:\n\n``` rust\nfn main() {\n    for numero in 1..10 {\n        if numero == 5 {\n            continue;  // Salta cuando número es 5\n        } else if numero == 8 {\n            break;  // Termina el bucle cuando número es 8\n        }\n        println!(\"Número: {numero}\");\n    }\n}\n```\n\n## Bloques y Ámbitos\n\nEn Rust, un bloque es un conjunto de declaraciones y expresiones encerradas entre llaves `{}`, que define un ámbito o scope. Los bloques permiten organizar el código y controlar la visibilidad y la duración de las variables.\n\n### Bloques\n\nUn bloque es simplemente un conjunto de instrucciones encerradas entre `{}`. Puedes usarlos en funciones, if, while, for y otras estructuras de control de flujo. Por ejemplo:\n\n``` rust\n\nfn main() {\n    let x = 5;\n    let y = {\n        let x = 3;\n        x + 1  // Este bloque devuelve 4\n    };\n    \n    println!(\"El valor de y es: {y}\");  // Imprime 4\n}\n```\n\nEn este caso, el valor de y se asigna al resultado del bloque {}, que devuelve 4. Dentro del bloque, el valor de x es 3, pero fuera del bloque sigue siendo 5. Esto demuestra cómo los bloques crean un nuevo ámbito.\n\n### Ámbitos (Scope)\n\nCada variable tiene un ámbito, que es el área del código donde la variable está visible y disponible para su uso. El ámbito comienza cuando se declara la variable y termina cuando el bloque que contiene la variable finaliza.\n\n``` rust\nfn main() {\n    let x = 5; // El ámbito de `x` comienza aquí\n\n    {\n        let y = 10;  // El ámbito de `y` comienza aquí\n        println!(\"Dentro del bloque: x = {x}, y = {y}\");\n    }  // El ámbito de `y` termina aquí\n\n    // Aquí, `y` ya no es accesible, pero `x` aún lo es\n    println!(\"Fuera del bloque: x = {x}\");\n}\n```\n\nEn el ejemplo anterior, y solo existe dentro del bloque interno. Intentar acceder a y fuera de ese bloque resultaría en un error, ya que su ámbito ha terminado. Sin embargo, x sigue accesible porque fue declarada en un ámbito más amplio (el bloque principal).\n\n### Sombra de Variables (Variable Shadowing)\n\nRust permite sombras de variables, lo que significa que puedes declarar una nueva variable con el mismo nombre en un nuevo bloque, y esta nueva variable “sombrea” la anterior.\n\n``` rust\nfn main() {\n    let x = 5;\n\n    {\n        let x = x * 2;  // Esta nueva `x` sombrea la anterior\n        println!(\"El valor de x dentro del bloque es: {x}\");  // Imprime 10\n    }\n\n    println!(\"El valor de x fuera del bloque es: {x}\");  // Imprime 5\n}\n```\n\nLa variable x dentro del bloque es independiente de la x fuera del bloque, y la versión de x fuera del bloque no se ve afectada por los cambios realizados dentro del bloque interno.\n\n### Duración de Vida (Lifetimes)\n\nEl ámbito también está relacionado con el concepto de duración de vida en Rust, que se refiere a cuánto tiempo vive una referencia o variable. Aunque no se necesita usar anotaciones de tiempo de vida en muchos casos, se volverán importantes cuando trabajes con referencias y prestamistas en bloques más complejos.\n\n## Funciones\n\nEn Rust, las funciones son un componente clave para organizar y reutilizar código. Permiten dividir el programa en partes más pequeñas y manejables. Toda función en Rust debe estar declarada con el tipo de datos que espera recibir (parámetros) y el tipo de dato que devolverá (si corresponde).\n\nDefinición de Funciones\n\nLa sintaxis básica para definir una función en Rust es la siguiente:\n\n``` rust\nfn nombre_de_la_funcion(parámetros: tipo) -> tipo_de_retorno {\n    // cuerpo de la función\n}\n```\n\n-   **fn**: Indica que estamos declarando una función.\n-   **nombre_de_la_funcion**: El nombre de la función, que sigue las convenciones de estilo `snake_case`.\n-   **parámetros**: Una lista de parámetros opcionales que la función toma como entrada.\n-   **tipo_de_retorno**: El tipo de valor que la función devolverá (si no devuelve nada, se omite).\n-   El **cuerpo de la función** es donde se especifica el comportamiento.\n\n\nEjemplo Simple de Función\n\nAquí tienes un ejemplo de una función que toma dos números enteros como parámetros y devuelve su suma:\n\n```rust\nfn sumar(a: i32, b: i32) -> i32 {\n    a + b  // El valor de retorno es la última expresión\n}\n\nfn main() {\n    let resultado = sumar(5, 3);\n    println!(\"El resultado es: {resultado}\");\n}\n```\n\nEn este ejemplo:\n\n- La función devuelve un valor de tipo `i32`, que es la suma de a y b.\n- La última expresión dentro de una función se devuelve automáticamente si no se termina con un punto y coma.\n\n**Parámetros**\n\nLos parámetros se definen dentro de los paréntesis cuando declaras una función, especificando tanto el nombre como el tipo de dato. Puedes pasar múltiples parámetros:\n\n```rust\nfn multiplicar(x: i32, y: i32) -> i32 {\n    x * y\n}\n```\nRust requiere que especifiques el tipo de todos los parámetros de la función.\n\n**Valores de Retorno**\n\nUna función puede devolver un valor usando una expresión o una instrucción `return` opcional. En Rust, la última expresión en el cuerpo de la función sin punto y coma se devuelve automáticamente.\n\n```rust\nfn cuadrado(x: i32) -> i32 {\n    return x * x;  // También puedes usar `return` explícitamente\n}\n```\n\nSi no deseas que la función devuelva un valor, puedes omitir la flecha `->` y el tipo de retorno, lo que significa que la función devolverá la unidad `()`:\n\n```rust\nfn saludar() {\n    println!(\"Hola, mundo!\");\n}\n```\n\n\n**Funciones con Referencias**\n\nRust también permite pasar referencias a las funciones, lo que es útil cuando no deseas transferir la propiedad de un valor. Las referencias permiten que la función lea el valor sin tomar posesión de él:\n\n\n```rust\nfn longitud(texto: &String) -> usize {\n    texto.len()\n}\n```\n\n\nEn este ejemplo, &String indica que la función toma una referencia al valor en lugar de transferir su propiedad.\n\n**Funciones Anidadas**\n\nPuedes definir funciones dentro de otras funciones en Rust, lo que se llama funciones anidadas. Esto puede ser útil para encapsular lógica específica dentro de un contexto limitado:\n\n```rust\nfn main() {\n    fn interna() {\n        println!(\"Esta es una función anidada\");\n    }\n\n    interna();  // Llamando a la función anidada\n}\n```\n\n**Funciones con Tipos Genéricos**\n\nRust permite que las funciones acepten tipos genéricos, lo que hace que las funciones sean más flexibles y reutilizables. Por ejemplo:\n\n\n```rust\nfn imprimir_dos_veces<T: std::fmt::Debug>(x: T) {\n    println!(\"{:?} {:?}\", x, x);\n}\n```\n\nAquí, `T` es un tipo genérico, y `std::fmt::Debug` es un trait que indica que el tipo debe poder imprimirse con `{:?}`.\n\n## Macros\n\nEn Rust, las macros son una poderosa característica que permite escribir código que genera otros fragmentos de código durante la compilación. Las macros permiten realizar tareas repetitivas, trabajar con estructuras complejas y proporcionar una mayor flexibilidad que las funciones estándar.\n\nA diferencia de las funciones, las macros pueden aceptar un número variable de argumentos y no están limitadas a trabajar solo con tipos específicos. Además, las macros en Rust se expanden antes de que el código sea compilado, lo que las hace útiles para metaprogramación.\n\n**Macros vs Funciones**\n\nAunque las macros y las funciones pueden parecer similares, tienen algunas diferencias clave:\n\n- Funciones: Se ejecutan en tiempo de ejecución y trabajan con parámetros de tipos específicos.\n\n- Macros: Se expanden en código en tiempo de compilación, lo que permite generar fragmentos de código personalizados.\n\nPor ejemplo, una función recibe un número fijo de argumentos de un tipo determinado, mientras que una macro puede manejar un número variable de argumentos de cualquier tipo. La exclamación `!` es lo que distingue a las macros de las funciones.\n\n\n**Macros Más Comunes**\n\nRust incluye varias macros predefinidas que son ampliamente utilizadas. Algunas de las más comunes son:\n\n`println!`: Imprime un mensaje formateado en la consola.\n\n```rust\nfn main() {\n    println!(\"Hola, mundo!\");\n}\n```\n\n`vec!`: Crea un vector con elementos iniciales.\n\n```rust\nfn main() {\n    let v = vec![1, 2, 3];\n    println!(\"{:?}\", v);\n}\n\n```\n\nLa macro vec! permite crear un vector con varios elementos sin tener que declarar su tipo explícitamente.\n\n\n**Defincición de Macros**\n\nLas macros se definen usando el macro sistema macro_rules!. A continuación, un ejemplo básico de cómo definir una macro que acepta dos expresiones y las imprime:\n\n```rust\nmacro_rules! saludar {\n    ($nombre:expr) => {\n        println!(\"Hola, {}!\", $nombre);\n    };\n}\n\nfn main() {\n    saludar!(\"Rust\");\n}\n```\n\nAquí, saludar! es la macro que toma un único argumento de tipo expresión ($nombre:expr) y genera una llamada a println! con ese argumento. El uso de $nombre:expr es parte de la sintaxis de las macros en Rust, que permite definir patrones y expandir el código.\n\n**Macros con Múltiples Patrones**\n\nLas macros pueden manejar múltiples patrones de entrada, lo que les permite comportarse de manera diferente dependiendo de cuántos o qué tipos de argumentos se les pasen:\n\n\n```rust\nmacro_rules! sumar {\n    ($a:expr, $b:expr) => {\n        println!(\"La suma es: {}\", $a + $b);\n    };\n    ($a:expr, $b:expr, $c:expr) => {\n        println!(\"La suma es: {}\", $a + $b + $c);\n    };\n}\n\nfn main() {\n    sumar!(2, 3);         // La suma es: 5\n    sumar!(2, 3, 4);      // La suma es: 9\n}\n\n```\n\nEn este ejemplo, la macro sumar! puede aceptar dos o tres argumentos y ejecutará una acción diferente según el número de parámetros proporcionados.\n\n\n**Macros Recursivas**\n\nRust también permite la creación de macros recursivas, que pueden llamarse a sí mismas hasta cumplir una condición. Esto es útil cuando necesitas generar estructuras de código repetitivas.\n\n```rust\nmacro_rules! contador {\n    ($primero:expr) => {\n        println!(\"{}\", $primero);\n    };\n    ($primero:expr, $($resto:expr),*) => {\n        println!(\"{}\", $primero);\n        contador!($($resto),*);\n    };\n}\n\nfn main() {\n    contador!(1, 2, 3, 4, 5);\n}\n```\n\nEste ejemplo imprime cada número en una nueva línea, y la macro se llama recursivamente hasta que solo queda un argumento.\n\n**Cuándo Usar Macros**\n\nLas macros son útiles cuando:\n\n* Necesitas generar código repetitivo.\n* Quieres aceptar una cantidad variable de argumentos o tipos de entrada.\n* Quieres realizar optimizaciones en tiempo de compilación.\n\nSin embargo, las macros deben usarse con cuidado, ya que pueden hacer que el código sea más difícil de leer y depurar debido a su naturaleza de metaprogramación. Se recomienda usarlas solo cuando las funciones no sean suficientes para el caso en cuestión.\n\n\n\n## Tipos Compuestos\n\nTuplas\n\n:   Agrupan múltiples valores de diferentes tipos en una única entidad. La longitud de una tupla es fija, y los tipos de los elementos pueden variar.\n\nEjemplo de tupla:\n\n``` rust\n\nlet tupla: (i32, f64, char) = (500, 6.4, 'a');\nlet (x, y, z) = tupla;  // Destructuring para acceder a los valores\n```\n\nArreglos (Arrays)\n\n:   Los arreglos contienen múltiples valores del mismo tipo. A diferencia de los vectores, los arreglos tienen una longitud fija que no puede cambiar.\n\nEjemplo de arreglo:\n\n``` rust\n\nlet arreglo: [i32; 5] = [1, 2, 3, 4, 5];  // Un arreglo de 5 enteros\nlet primer_elemento = arreglo[0];  // Acceder al primer elemento\n```\n\nAquí tienes una tabla para los tipos compuestos:\n\n| Tipo | Sintaxis | Ejemplos |\n|---------------|-----------------------|----------------------------------|\n| Tuplas | (T1, T2, T3, ...) | (500, 6.4, 'a') |\n| Arreglos | \\[T; N\\] (T es tipo, N es tamaño) | \\[1, 2, 3, 4, 5\\], \\[3.14; 3\\] (inicializa con 3.14 tres veces) |\n\n\n\n## Iteradores\n\nUn iterador es una estructura que permite recorrer una secuencia de elementos, como un arreglo, una lista o cualquier colección de datos, uno a la vez. En Rust, los iteradores son una herramienta poderosa y flexible, que se pueden usar para manipular y procesar colecciones de manera eficiente y expresiva.\n\n**¿Qué es un Iterador?**\n\nEn Rust, un iterador es cualquier tipo que implemente el trait Iterator. Los iteradores proporcionan dos funciones principales:\n\nnext\n: Proporciona acceso al siguiente elemento en la secuencia. Cuando no hay más elementos, devuelve None.\n\nMétodos de adaptación\n: Métodos como map, filter, y collect que permiten transformar los iteradores.\n\nEjemplo básico de uso de next:\n\n```rust\nfn main() {\n    let numeros = vec![1, 2, 3];\n    let mut iter = numeros.iter();\n\n    println!(\"{:?}\", iter.next());  // Imprime Some(1)\n    println!(\"{:?}\", iter.next());  // Imprime Some(2)\n    println!(\"{:?}\", iter.next());  // Imprime Some(3)\n    println!(\"{:?}\", iter.next());  // Imprime None\n}\n```\n\n**Crear un Iterador**\n\nLa mayoría de las colecciones en Rust pueden convertirse en iteradores usando el método iter. Para iterar sobre un vector o un array:\n\n```rust\nfn main() {\n    let numeros = vec![1, 2, 3, 4, 5];\n    \n    for numero in numeros.iter() {\n        println!(\"{}\", numero);\n    }\n}\n```\n\nEn este caso, `numeros.iter()` devuelve un iterador sobre el vector numeros. El ciclo for se encarga de llamar a `next` por nosotros y obtiene cada elemento en la secuencia.\n\n**Métodos de Adaptación de Iteradores**\n\nRust proporciona varios métodos de iterador que permiten transformar, filtrar y combinar secuencias de manera eficiente. Estos métodos no consumen el iterador, sino que devuelven un nuevo iterador, lo que permite encadenarlos de manera elegante.\n\nAlgunos de los métodos más comunes son:\n\n`map`\n: Aplica una función a cada elemento y devuelve un nuevo iterador con los resultados.\n\n```rust\nfn main() {\n    let numeros = vec![1, 2, 3, 4];\n    let cuadrados: Vec<i32> = numeros.iter().map(|x| x * x).collect();\n    println!(\"{:?}\", cuadrados);  // Imprime [1, 4, 9, 16]\n}\n```\n\n`filter`\n: Filtra elementos según una condición.\n\n```rust\nfn main() {\n    let numeros = vec![1, 2, 3, 4, 5];\n    let pares: Vec<i32> = numeros.iter().filter(|&&x| x % 2 == 0).collect();\n    println!(\"{:?}\", pares);  // Imprime [2, 4]\n}\n```\n\n`collect`\n: Convierte un iterador en una colección, como un `Vec`, un HashMap, entre otros.\n\n\n```rust\nfn main() {\n    let numeros = vec![1, 2, 3, 4];\n    let resultado: Vec<i32> = numeros.iter().map(|x| x + 1).collect();\n    println!(\"{:?}\", resultado);  // Imprime [2, 3, 4, 5]\n}\n```\n\n`enumerate`\n: Asigna un índice a cada elemento del iterador.\n\n```rust\nfn main() {\n    let numeros = vec![\"a\", \"b\", \"c\"];\n    for (i, letra) in numeros.iter().enumerate() {\n        println!(\"Índice: {}, Letra: {}\", i, letra);\n    }\n}\n```\n\n\n**Consumo de Iteradores**\n\nAlgunos métodos de iterador consumen el iterador, lo que significa que una vez que el método ha sido ejecutado, el iterador ya no puede ser utilizado. Algunos ejemplos de métodos que consumen iteradores son:\n\n`sum`\n: Calcula la suma de todos los elementos de un iterador numérico.\n\t\n```rust\nfn main() {\n    let numeros = vec![1, 2, 3, 4];\n    let suma: i32 = numeros.iter().sum();\n    println!(\"La suma es: {}\", suma);  // Imprime 10\n}\n```\n\n`find`\n: Busca el primer elemento que cumpla con una condición.\n\n```rust\nfn main() {\n    let numeros = vec![1, 2, 3, 4];\n    if let Some(num) = numeros.iter().find(|&&x| x == 3) {\n        println!(\"Número encontrado: {}\", num);  // Imprime 3\n    }\n}\n```\n\n\n**Iteradores Inmutables y Mutables**\n\nRust te permite crear tanto iteradores inmutables como iteradores mutables. Los iteradores inmutables (iter()) te permiten acceder a los elementos de una colección sin modificarla, mientras que los iteradores mutables (iter_mut()) te permiten modificar los elementos mientras los recorres.\n\n```rust\nfn main() {\n    let mut numeros = vec![1, 2, 3, 4];\n\n    for num in numeros.iter_mut() {\n        *num += 1;\n    }\n    \n    println!(\"{:?}\", numeros);  // Imprime [2, 3, 4, 5]\n}\n```\n\n**Creación de Iteradores Personalizados**\n\nAdemás de usar los iteradores integrados, también puedes implementar el trait Iterator para crear tus propios iteradores personalizados. Esto te permite definir cómo deben comportarse tus estructuras de datos al ser iteradas.\n\n```rust\nstruct Contador {\n    actual: u32,\n    limite: u32,\n}\n\nimpl Contador {\n    fn nuevo(limite: u32) -> Contador {\n        Contador { actual: 0, limite }\n    }\n}\n\nimpl Iterator for Contador {\n    type Item = u32;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        if self.actual < self.limite {\n            self.actual += 1;\n            Some(self.actual)\n        } else {\n            None\n        }\n    }\n}\n\nfn main() {\n    let mut contador = Contador::nuevo(5);\n\n    while let Some(valor) = contador.next() {\n        println!(\"{}\", valor);\n    }\n}\n```\nEn este ejemplo, se define un iterador personalizado Contador que genera una secuencia de números de 1 a limite.\n\n\n## Closures\n\nUn closure (o cierre) en Rust es una función anónima que puede capturar variables del entorno en el que se define. Los closures son muy flexibles y pueden aceptar parámetros, devolver valores y, a diferencia de las funciones normales, pueden capturar y utilizar variables que no se les pasan explícitamente.\n\nLos closures se definen usando la siguiente sintaxis:\n\n```rust\n|parametros| expresión\n```\n\nSon comunes en Rust para trabajar con iteradores y otras operaciones funcionales, como map y filter.\n\n**Definición Básica**\n\nAquí tienes un ejemplo básico de un closure que suma dos números:\n\n```rust\nfn main() {\n    let suma = |a, b| a + b;\n    println!(\"La suma es: {}\", suma(2, 3));\n}\n```\n\n\nEn este ejemplo:\n\n- `|a, b|` es la lista de parámetros del closure.\n- `a + b` es la expresión que se ejecuta cuando se llama al closure.\n- Se llama al closure con suma(2, 3), y el resultado es 5.\n\n**Captura de Variables**\n\nUna característica clave de los closures es su capacidad para capturar variables del entorno en el que fueron definidos. Pueden capturar variables por referencia, por préstamo mutable o por posesión, dependiendo de cómo se utilicen.\n\n```rust\nfn main() {\n    let x = 4;\n    let closure = |y| x + y;\n    println!(\"Resultado: {}\", closure(3));  // Imprime 7\n}\n```\nEn este caso, el closure closure captura la variable x del entorno y la utiliza en su cuerpo.\n\n**Closures que Capturan por Referencia, Mutable y por Posesión**\n\nLos closures pueden capturar variables de diferentes maneras:\n\nPor referencia\n: El closure accede a la variable sin tomar posesión de ella.\n\n```rust\nfn main() {\n    let x = 5;\n    let capturar_x = || println!(\"x: {}\", x);  // Captura `x` por referencia\n    capturar_x();\n}\n```\n\n\nPor mutabilidad\n: El closure puede modificar la variable.\n\n```rust\nfn main() {\n    let mut x = 5;\n    let mut modificar_x = || x += 1;  // Captura `x` por mutabilidad\n    modificar_x();\n    println!(\"x: {}\", x);  // Imprime 6\n}\n```\n\n\nPor posesión\n: El closure toma posesión de la variable, lo que impide su uso fuera del closure.\n\n```rust\nfn main() {\n    let x = String::from(\"Hola\");\n    let capturar_x = || {\n        let _y = x;  // Captura `x` por posesión\n    };\n    capturar_x();\n    // Aquí `x` ya no es accesible porque fue capturado por posesión\n}\n```\n\n**Closures con Tipos y Anotaciones de Parámetros**\n\nEn la mayoría de los casos, Rust puede inferir los tipos de los parámetros de un closure, por lo que no es necesario especificarlos. Sin embargo, también puedes hacerlo explícitamente si lo deseas:\n\n```rust\nfn main() {\n    let suma = |a: i32, b: i32| -> i32 { a + b };\n    println!(\"La suma es: {}\", suma(10, 5));\n}\n```\nEn este caso, hemos anotado los tipos de los parámetros (i32) y el tipo de retorno del closure (i32).\n\n\nClosures y Funciones\n\nA diferencia de las funciones, los closures pueden capturar variables del entorno. Sin embargo, los closures y las funciones comparten algunas similitudes. Los closures se pueden almacenar en variables, pasar como argumentos o devolver desde otras funciones, al igual que las funciones.\n\nLos closures también pueden ser pasados como parámetros a funciones que esperan un trait como `Fn`, `FnMut`, o `FnOnce`\n\n**Traits Fn, FnMut, y FnOnce**\n\nRust proporciona tres traits principales para closures, dependiendo de cómo el closure maneje las variables capturadas:\n\n1.\tFn: El closure no modifica ni toma posesión de las variables que captura. Se llama múltiples veces sin efectos secundarios.\n2.\tFnMut: El closure puede modificar las variables que captura, pero no toma posesión de ellas. Se llama múltiples veces, pero puede tener efectos secundarios.\n3.\tFnOnce: El closure toma posesión de las variables que captura, por lo que solo puede ser llamado una vez.\n\nPor ejemplo:\n\n\n```rust\nfn ejecutar_closure<F>(f: F) \nwhere\n    F: Fn(i32) -> i32 \n{\n    println!(\"Resultado: {}\", f(5));\n}\n\nfn main() {\n    let closure = |x| x + 1;\n    ejecutar_closure(closure);\n}\n\n```\nAquí, ejecutar_closure acepta un parámetro F que implementa el trait Fn, lo que permite pasarle closures que no modifican las variables capturadas.\n\n**Closures como Retorno**\n\nTambién puedes devolver un closure desde una función, utilizando el trait adecuado:\n\n```rust\nfn crear_closure() -> impl Fn(i32) -> i32 {\n    |x| x + 1\n}\n\nfn main() {\n    let mi_closure = crear_closure();\n    println!(\"Resultado: {}\", mi_closure(10));  // Imprime 11\n}\n```\n\nAquí, la función crear_closure devuelve un closure que toma un entero y devuelve ese entero incrementado en uno.\n\n**Closures en Iteradores**\n\nLos closures son ampliamente utilizados en operaciones con iteradores, como map, filter, fold, entre otros. Estos métodos aceptan closures para realizar operaciones sobre cada elemento de una colección.\n\nPor ejemplo, el uso de un closure con map para elevar al cuadrado los números de un vector:\n\n```rust\nfn main() {\n    let numeros = vec![1, 2, 3, 4];\n    let cuadrados: Vec<i32> = numeros.iter().map(|x| x * x).collect();\n    println!(\"{:?}\", cuadrados);  // Imprime [1, 4, 9, 16]\n}\n```\n\n\n## Manejo de errores\n\nEn Rust, el manejo de errores se divide en dos categorías principales: errores recuperables (gestionados con Result) y errores irrecuperables (gestionados con panic!).\n\nResult: Errores Recuperables\n\nEl tipo Result es usado cuando una operación puede tener éxito o fallar. Tiene dos variantes:\n\n- Ok(T): Representa un éxito y contiene un valor.\n- Err(E): Representa un error y contiene información del mismo.\n\nEjemplo básico:\n\n```rust\nuse std::fs::File;\n\nfn main() {\n    let archivo = File::open(\"archivo.txt\");\n\n    match archivo {\n        Ok(_) => println!(\"Archivo abierto.\"),\n        Err(e) => println!(\"Error: {}\", e),\n    }\n}\n```\n\nTambién puedes usar el operador ? para simplificar el manejo de errores, propagando el error si ocurre:\n\n```rust\nfn leer_archivo() -> Result<String, std::io::Error> {\n    let mut archivo = File::open(\"archivo.txt\")?;\n    let mut contenido = String::new();\n    archivo.read_to_string(&mut contenido)?;\n    Ok(contenido)\n}\n```\n\n**Option: Valores Opcionales**\n\nOption es usado para manejar valores que pueden estar presentes o no. Tiene dos variantes:\n\n- Some(T): Representa un valor.\n- None: Representa la ausencia de un valor.\n\nEjemplo:\n\n```rust\nfn dividir(dividendo: f64, divisor: f64) -> Option<f64> {\n    if divisor == 0.0 {\n        None\n    } else {\n        Some(dividendo / divisor)\n    }\n}\n```\n\n**panic!: Errores Irrecuperables**\n\nCuando ocurre un error grave del que el programa no puede recuperarse, se usa panic! para detener la ejecución:\n\n\n```rust\nfn main() {\n    panic!(\"¡Error grave!\");\n}\n```\n\n\n","srcMarkdownNoYaml":""},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":false,"cache":null,"freeze":false,"echo":true,"output":true,"warning":false,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"markdown"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"center","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","html-math-method":"katex","css":["styles/style.css"],"output-file":"concepts.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.4.554","bibliography":["references.bib"],"editor":"source","always_allow_html":true,"_quarto-vars":{"version":1,"email":{"author":"<denis.berroeta@uai.cl>"},"profesor":{"name":"[Denis Berroeta](https://cit.uai.cl/denis-berroeta/)","cargo":"Coordinador de Investigación, Centro de Inteligencia Territorial - UAI","email":"<denis.berroeta@uai.cl>"},"engine":{"jupyter":"[Jupyter](https://jupyter.org)","knitr":"[Knitr](<https://yihui.name/knitr>)","R":"[R Project](https://www.r-project.org)","python":"[Python](https://docs.python.org/es/3/tutorial/)"},"software":{"rstudio":"[RStudio](https://posit.co/products/open-source/rstudio/)"},"library":{"sf":"[Simple Features for R](https://r-spatial.github.io/sf/articles/sf1.html)","dplyr":"[dplyr](https://dplyr.tidyverse.org)","purrr":"[purrr](https://purrr.tidyverse.org)","mapview":"[mapview](https://r-spatial.github.io/mapview/)","lubridate":"[lubridate](https://lubridate.tidyverse.org)","tidyr":"[tidyr](https://tidyr.tidyverse.org)","plotly":"[plotly](https://plotly.com/r/)","ggplot":"[ggplot2](https://ggplot2.tidyverse.org/)"},"organization":{"ine":"[Instituto Nacional de Estadísticas](https://www.ine.gob.cl)","cran":"[CRAN (Comprehensive R Archive Network)](https://cran.r-project.org/)","bioconductor":"[Bioconductor](https://www.bioconductor.org/)","github":"[Github](https://github.com/)","rforge":"[R-Forge](https://r-forge.r-project.org/)"}},"theme":"cosmo","fig-cap-location":"margin","tab-cap-location":"left","mailto":"denis.berroeta@uai.cl","code-block-bg":true,"code-block-border-left":"#31BAE9"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}