{"title":"Instalación","markdown":{"yaml":{"title":"Instalación","highlight-style":"arrow","execute":{"eval":false}},"headingText":"Intalar Rust","containsRefs":false,"markdown":"\n\n\nEste capítulo explica cómo instalar Rust, cómo escribir un programa “Hola, mundo!” Y cómo usar Cargo, el administrador de paquetes y herramienta de compilación de Rust. \n\n\n\n\nEl primer paso es instalar Rust. Descargaremos Rust a través de `rustup`, una\nherramienta de línea de comandos para administrar las versiones de Rust y las\nherramientas asociadas. Necesitarás una conexión a Internet para la descarga.\n\n\n\n### Instalación de `rustup` en Linux o macOS\n\nSi estás utilizando Linux o macOS, abre una terminal y escribe lo siguiente\n\n```console\ncurl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf | sh\n```\n\nEl comando descarga un script y comienza la instalación de la herramienta\n`rustup`, que instala la última versión estable de Rust. Es posible que se te\nsolicite tu contraseña. Si la instalación es exitosa, aparecerá la siguiente\nlínea:\n\n```text\nRust is installed now. Great!\n```\n\nTambién necesitarás un *enlazador*, que es un programa que Rust utiliza para\nunir sus salidas compiladas en un solo archivo. Es probable que ya lo tengas.\nSi obtienes errores de enlace, debes instalar un compilador C, que generalmente\nincluye un enlazador. Un compilador C también es útil porque algunos paquetes\ncomunes de Rust dependen de código C y necesitarán un compilador C.\n\nEn macOS, puedes obtener un compilador C ejecutando:\n\n```console\nxcode-select --install\n```\n\nLos usuarios de Linux deben instalar generalmente GCC o Clang, según la\ndocumentación de su distribución. Por ejemplo, si usas Ubuntu, puede instalar el\npaquete `build-essential`.\n\n### Instalación de `rustup` en Windows\n\nEn Windows, ve a [https://www.rust-lang.org/tools/install][install] y sigue las\ninstrucciones para instalar Rust. En algún momento de la instalación, recibirás\nun mensaje para instalar Visual Studio. Este provee un linker y las bibliotecas\nnativas necesarias para compilar programas. \n\nPara obtener las herramientas de compilación, deberás instalar \n[Visual Studio][visualstudio]. Cuando se te pregunte qué paquetes de trabajo \ninstalar, incluye:\n\n* “Desarrollo de escritorio con C ++”\n* El SDK de Windows 10 o 11\n* El componente de paquete de idioma inglés, junto con cualquier otro paquete de\n  idioma de tu elección\n\nEl resto de este libro usa comandos que funcionan tanto en *cmd.exe* como en\nPowerShell. Si hay diferencias específicas, explicaremos cuál usar.\n\n\n### Solución de problemas\n\nPara verificar si has instalado Rust correctamente, abra una shell y escribe esta\nlínea:\n\n```shell\n$ rustc --version\n```\n\nDeberías ver el número de versión, el hash de confirmación y la fecha de\nconfirmación de la última versión estable que se ha publicado, en el siguiente\nformato:\n\n```text\nrustc x.y.z (abcabcabc yyyy-mm-dd)\n```\n\nSi ves esta información, ¡has instalado Rust correctamente! Si no ves esta\ninformación, verifica que Rust esté en la variable de sistema `%PATH%` de la\nsiguiente manera.\n\nEn Windows CMD, usa:\n\n```console\n> echo %PATH%\n```\n\nEn PowerShell, usa:\n\n```console\n> echo $env:Path\n```\n\nEn Linux y macOS, usa:\n\n```console\n$ echo $PATH\n```\n\n\n### Actualización y desinstalación\n\nUna vez que Rust se instala a través de `rustup`, actualizar a una versión\nrecién lanzada es fácil. Desde tu shell, ejecuta el siguiente script de\nactualización:\n\n```console\n$ rustup update\n```\n\nPara desinstalar Rust y `rustup`, ejecuta el siguiente script de desinstalación\ndesde tu shell:\n\n```console\n$ rustup self uninstall\n```\n\n### Documentación local\n\nLa instalación de Rust también incluye una copia local de la documentación para\nque puedas leerla sin conexión. Ejecuta `rustup doc` para abrir la documentación\nlocal en tu navegador.\n\nEn cualquier momento en que se proporcione un tipo o una función de la biblioteca\nestándar y no estés seguro de lo que hace o cómo usarlo, usa la documentación de\nla interfaz de programación de aplicaciones (API) para averiguarlo.\n\n[otherinstall]: https://forge.rust-lang.org/infra/other-installation-methods.html\n[install]: https://www.rust-lang.org/tools/install\n[msvc]: https://rust-lang.github.io/rustup/installation/windows-msvc.html\n[community]: https://www.rust-lang.org/community\n[visualstudio]: https://visualstudio.microsoft.com/downloads/\n\n\n## Hello World\n\n\nAhora que has instalado Rust, es hora de escribir tu primer programa en Rust.\nEs tradicional cuando se aprende un nuevo lenguaje escribir un pequeño programa\nque imprima el texto `¡Hola, mundo!` en la pantalla.\n\n\n\n## Instalar Cargo\n\nCargo es el sistema de compilación y administrador de paquetes de Rust. La\nmayoría de los Rustaceans usan esta herramienta para administrar sus proyectos\nRust porque Cargo maneja muchas tareas para ti, como compilar tu código,\ndescargar las bibliotecas de las que depende tu código y compilar esas\nbibliotecas. (Llamamos *dependencias* a las bibliotecas de las que depende tu\ncódigo).\n\nLos programas Rust más simples, como el que hemos escrito hasta ahora, no\ntienen dependencias. Si hubiéramos construido el proyecto “¡Hola, mundo!” con\nCargo, sólo usaría la parte de Cargo que maneja la compilación de tu código. A\nmedida que escribas programas Rust más complejos, agregarás dependencias, y si\ncomienzas un proyecto usando Cargo, agregar dependencias será mucho más fácil\nde hacer.\n\nDebido a que la gran mayoría de los proyectos Rust usan Cargo, el resto de este\nlibro asume que también estás usando Cargo. Cargo viene instalado con Rust si\nusaste los instaladores oficiales que se discuten en la sección\n[“Installation”][installation]<!-- ignore -->. Si instalaste Rust a través de\nalgunos otros medios, verifica si Cargo está instalado ingresando lo siguiente\nen tu terminal:\n\n```console\n$ cargo --version\n```\n\nSi ves un número de versión, ¡lo tienes! Si ves un error, como `command not found`,\nconsulta la documentación de tu método de instalación para determinar cómo\ninstalar Cargo por separado.\n\n### Creación de un proyecto con Cargo\n\nVamos a crear un nuevo proyecto usando Cargo y ver cómo difiere de nuestro\nproyecto original “¡Hola, mundo!”. Navega de vuelta a tu directorio\n*proyectos* (o dondequiera que hayas decidido almacenar tu código). Luego, en\ncualquier sistema operativo, ejecuta lo siguiente:\n\n```console\n$ cargo new hello_cargo\n$ cd hello_cargo\n```\n\nEl primer comando crea un nuevo directorio y proyecto llamado *hello_cargo*.\nHemos nombrado a nuestro proyecto *hello_cargo*, y Cargo crea sus archivos en\nun directorio con el mismo nombre.\n\nVe al directorio *hello_cargo* y lista los archivos. Verás que Cargo ha\ngenerado dos archivos y un directorio para nosotros: un archivo *Cargo.toml* y\nun directorio *src* con un archivo *main.rs* dentro.\n\nTambién ha inicializado un nuevo repositorio Git junto con un archivo\n*.gitignore*. Los archivos Git no se generarán si ejecutas `cargo new` dentro\nde un repositorio Git existente; puedes anular este comportamiento usando\n`cargo new --vcs=git`.\n\n> Nota: Git es un sistema de control de versiones común. Puedes cambiar `cargo\n> new` para usar un sistema de control de versiones diferente o ningún sistema\n> de control de versiones usando la bandera `--vcs`. Ejecuta `cargo new --help`\n> para ver las opciones disponibles.\n\nAbre *Cargo.toml* en tu editor de texto de elección. Debería verse similar al\ncódigo del Listado 1-2.\n\n<Listing number=\"1-2\" file-name=\"Cargo.toml\" caption=\"Contenido de *Cargo.toml* generado por `cargo new`\">\n\n```toml\n[package]\nname = \"hello_cargo\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n\n[dependencies]\n```\n\n</Listing>\n\nEste archivo está en el formato [*TOML*][toml]<!-- ignore --> (*Tom’s Obvious,\nMinimal Language*), que es el formato de configuración de Cargo.\n\nLa primera línea, `[package]`, es un encabezado de sección que indica que las\nsiguientes declaraciones están configurando un paquete. A medida que agreguemos\nmás información a este archivo, agregaremos otras secciones.\n\nLas próximas tres líneas establecen la información de configuración que Cargo\nnecesita para compilar tu programa: el nombre, la versión y la edición de Rust\nque se usará. Hablaremos sobre la entrada `edition` en [Apéndice E][appendix-e]\n<!-- ignore -->.\n\nLa última línea, `[dependencies]`, es el comienzo de una sección para que\nenumere cualquier dependencia de tu proyecto. En Rust, los paquetes de código\nse denominan *crates*. No necesitaremos otros crates para este proyecto, pero\nlo haremos en el primer proyecto del Capítulo 2, por lo que usaremos esta\nsección de dependencias hasta entonces.\n\nAhora abre *src/main.rs* y echa un vistazo:\n\n<span class=\"filename\">Nombre de archivo: src/main.rs</span>\n\n```rust\nfn main() {\n    println!(\"Hello, world!\");\n}\n```\n\n¡Cargo ha generado un programa “Hello, world!”/“¡Hola, mundo!” para ti, \n¡igual que el que escribimos enl Listado 1-1! Hasta ahora, las diferencias \nentre nuestro proyecto y el proyecto generado por Cargo son que Cargo \ncolocó el código en el directorio *src* y tenemos un archivo de \nconfiguración *Cargo.toml* en el directorio superior.\n\nCargo espera que tus archivos de origen vivan dentro del directorio *src*. El\ndirectorio del proyecto de nivel superior es solo para archivos README, \ninformación de licencia, archivos de configuración y cualquier otra cosa \nque no esté relacionada con tu código. Usar Cargo te ayuda a organizar \ntus proyectos. Hay un lugar para todo, y todo está en su lugar.\n\nSi comenzaste un proyecto que no usa Cargo, como hicimos con el proyecto\n“¡Hola, mundo!”, puedes convertirlo en un proyecto que sí use Cargo. Mueve el\ncódigo del proyecto al directorio *src* y crea un archivo *Cargo.toml*\nadecuado.\n\n### Construir y ejecutar un proyecto de Cargo\n\nAhora veamos qué es diferente cuando construimos y ejecutamos el programa\n“¡Hola, mundo!” con Cargo. ¡Desde tu directorio *hello_cargo*, construye tu\nproyecto ingresando el siguiente comando:\n\n```console\n$ cargo build\n   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)\n    Finished dev [unoptimized + debuginfo] target(s) in 2.85 secs\n```\n\nEste comando crea un archivo ejecutable en *target/debug/hello_cargo* (o\n*target\\debug\\hello_cargo.exe* en Windows) en lugar de en tu directorio\nactual. Debido a que la compilación predeterminada es una compilación de\ndepuración, Cargo coloca el binario en un directorio llamado *debug*. Puedes\nllamar al ejecutable con este comando:\n\n```console\n$ ./target/debug/hello_cargo # o .\\target\\debug\\hello_cargo.exe en Windows\nHello, world!\n```\n\nSi todo va bien, `Hello, world!` debería imprimirse en la terminal. Ejecutar\n`cargo build` por primera vez también hace que Cargo cree un nuevo archivo en\nel nivel superior: *Cargo.lock*. Este archivo rastrea las versiones exactas de\nlas dependencias de tu proyecto. Este proyecto no tiene dependencias, por lo\nque el archivo es un poco escaso. Nunca necesitarás cambiar este archivo\nmanualmente; Cargo administra su contenido para ti.\n\nAcabamos de construir un proyecto con `cargo build` y ejecutarlo con\n`./target/debug/hello_cargo`, pero también podemos usar `cargo run` para\ncompilar el código y luego llamar al ejecutable resultante en un solo\ncomando:\n\n```console\n$ cargo run\n    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs\n     Running `target/debug/hello_cargo`\nHello, world!\n```\n\nUsar `cargo run` es más conveniente que tener que recordar ejecutar `cargo\nbuild` y luego usar la ruta completa al binario, por lo que la mayoría de los\ndesarrolladores usan `cargo run`.\n\nTen en cuenta que esta vez no vimos salida que indicara que Cargo estaba\ncompilando `hello_cargo`. Cargo supo que los archivos no habían cambiado, por\nlo que no volvió a construir, sino que solo ejecutó el binario. Si hubieras\nmodificado tu código fuente, Cargo habría reconstruido el proyecto antes de\nejecutarlo, y habrías visto esta salida:\n\n```console\n$ cargo run\n   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.33 secs\n     Running `target/debug/hello_cargo`\nHello, world!\n```\n\nCargo también proporciona un comando llamado `cargo check`. Este comando\ncomprueba rápidamente tu código para asegurarse de que compila, pero no\nproduce un ejecutable:\n\n```console\n$ cargo check\n   Checking hello_cargo v0.1.0 (file:///projects/hello_cargo)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.32 secs\n```\n\n¿Por qué no querrías un ejecutable? A menudo, `cargo check` es mucho más rápido\nque `cargo build` porque omite el paso de producir un ejecutable. Si estás\nverificando continuamente tu trabajo mientras escribes el código, usar\n`cargo check` acelerará el proceso de informarte si tu proyecto todavía aún está\ncompilando. ¡Por lo tanto, muchos Rustaceans ejecutan `cargo check`\nperiódicamente mientras escriben su programa para asegurarse de que compila!\nLuego ejecutan `cargo build` cuando están listos para usar el ejecutable.\n\nResumamos lo que hemos aprendido hasta ahora sobre Cargo:\n\n* Podemos crear un proyecto usando `cargo new`.\n* Podemos construir un proyecto usando `cargo build`.\n* Podemos construir y ejecutar un proyecto en un solo paso usando `cargo run`.\n* Podemos construir un proyecto sin producir un binario para verificar errores\n  usando `cargo check`.\n* En lugar de guardar el resultado de la compilación en el mismo directorio que\n  nuestro código, Cargo lo almacena en el directorio *target/debug*.\n\nUna ventaja adicional de usar Cargo es que los comandos son los mismos sin\nimportar en qué sistema operativo estés trabajando. Por lo tanto, en este\npunto, ya no proporcionaremos instrucciones específicas para Linux y macOS\nversus Windows.\n\n### Construyendo una versión de lanzamiento\n\nCuando tu proyecto finalmente esté listo para su lanzamiento, puedes usar `cargo\nbuild --release` para compilarlo con optimizaciones. Este comando creará un\nejecutable en *target/release* en lugar de *target/debug*. Las optimizaciones\nhacen que tu código Rust se ejecute más rápido, pero al activarlos se alarga el\ntiempo que tarda tu programa en compilarse. Es por eso que hay dos perfiles\ndiferentes: uno para el desarrollo, cuando deseas reconstruir rápidamente y\ncon frecuencia, y otro para construir el programa final que le darás al usuario,\nque no se reconstruirá repetidamente y que se ejecutará lo más rápido posible.\nSi estás midiendo el tiempo de ejecución de tu código, asegúrate de ejecutar\n`cargo build --release` y realizar la prueba de rendimiento con el ejecutable\nen *target/release*.\n\n### Cargo como convención\n\nCon proyectos simples, Cargo no proporciona mucho valor por sobre sólo usar\n`rustc`, pero demostrará su valor a medida que tus programas se vuelvan más\nintrincados. Una vez que los programas crecen a múltiples archivos o necesitan\nuna dependencia, es mucho más fácil dejar que Cargo coordine la construcción.\n\nAunque el proyecto `hello_cargo` es simple, ahora usas muchas de las herramientas\nreales que usarás en el resto de tu carrera en Rust. De hecho, para trabajar en\ncualquier proyecto existente, puedes usar los siguientes comandos para verificar\nel código usando Git, cambiar al directorio del proyecto y construir:\n\n\n```console\n$ git clone example.org/someproject\n$ cd someproject\n$ cargo build\n```\n\nPara obtener más información sobre Cargo, consulta [su documentación][cargo].\n\n[toml]: https://toml.io\n[cargo]: https://doc.rust-lang.org/cargo/\n\n\n## Extensiones para VS Code\n\n\n\n\n\nPuede encontrar e instalar la extensión rust-analyzer desde VS Code a través de la vista Extensiones (⇧⌘X) y buscando `rust-analyzer`. Debe instalar la versión de lanzamiento.\n\n![Extensión para Visual Studio Code llamada [rust-analyzer](https://code.visualstudio.com/docs/languages/rust)](images/Rust with VS Code.png)\n\n\nPuedes consultar la documentación de la extensión en [https://rust-analyzer.github.io](https://rust-analyzer.github.io).\n\n\nhttps://www.youtube.com/watch?v=Vde3-UUZAvU\n\n\n","srcMarkdownNoYaml":"\n\n\nEste capítulo explica cómo instalar Rust, cómo escribir un programa “Hola, mundo!” Y cómo usar Cargo, el administrador de paquetes y herramienta de compilación de Rust. \n\n\n## Intalar Rust\n\n\nEl primer paso es instalar Rust. Descargaremos Rust a través de `rustup`, una\nherramienta de línea de comandos para administrar las versiones de Rust y las\nherramientas asociadas. Necesitarás una conexión a Internet para la descarga.\n\n\n\n### Instalación de `rustup` en Linux o macOS\n\nSi estás utilizando Linux o macOS, abre una terminal y escribe lo siguiente\n\n```console\ncurl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf | sh\n```\n\nEl comando descarga un script y comienza la instalación de la herramienta\n`rustup`, que instala la última versión estable de Rust. Es posible que se te\nsolicite tu contraseña. Si la instalación es exitosa, aparecerá la siguiente\nlínea:\n\n```text\nRust is installed now. Great!\n```\n\nTambién necesitarás un *enlazador*, que es un programa que Rust utiliza para\nunir sus salidas compiladas en un solo archivo. Es probable que ya lo tengas.\nSi obtienes errores de enlace, debes instalar un compilador C, que generalmente\nincluye un enlazador. Un compilador C también es útil porque algunos paquetes\ncomunes de Rust dependen de código C y necesitarán un compilador C.\n\nEn macOS, puedes obtener un compilador C ejecutando:\n\n```console\nxcode-select --install\n```\n\nLos usuarios de Linux deben instalar generalmente GCC o Clang, según la\ndocumentación de su distribución. Por ejemplo, si usas Ubuntu, puede instalar el\npaquete `build-essential`.\n\n### Instalación de `rustup` en Windows\n\nEn Windows, ve a [https://www.rust-lang.org/tools/install][install] y sigue las\ninstrucciones para instalar Rust. En algún momento de la instalación, recibirás\nun mensaje para instalar Visual Studio. Este provee un linker y las bibliotecas\nnativas necesarias para compilar programas. \n\nPara obtener las herramientas de compilación, deberás instalar \n[Visual Studio][visualstudio]. Cuando se te pregunte qué paquetes de trabajo \ninstalar, incluye:\n\n* “Desarrollo de escritorio con C ++”\n* El SDK de Windows 10 o 11\n* El componente de paquete de idioma inglés, junto con cualquier otro paquete de\n  idioma de tu elección\n\nEl resto de este libro usa comandos que funcionan tanto en *cmd.exe* como en\nPowerShell. Si hay diferencias específicas, explicaremos cuál usar.\n\n\n### Solución de problemas\n\nPara verificar si has instalado Rust correctamente, abra una shell y escribe esta\nlínea:\n\n```shell\n$ rustc --version\n```\n\nDeberías ver el número de versión, el hash de confirmación y la fecha de\nconfirmación de la última versión estable que se ha publicado, en el siguiente\nformato:\n\n```text\nrustc x.y.z (abcabcabc yyyy-mm-dd)\n```\n\nSi ves esta información, ¡has instalado Rust correctamente! Si no ves esta\ninformación, verifica que Rust esté en la variable de sistema `%PATH%` de la\nsiguiente manera.\n\nEn Windows CMD, usa:\n\n```console\n> echo %PATH%\n```\n\nEn PowerShell, usa:\n\n```console\n> echo $env:Path\n```\n\nEn Linux y macOS, usa:\n\n```console\n$ echo $PATH\n```\n\n\n### Actualización y desinstalación\n\nUna vez que Rust se instala a través de `rustup`, actualizar a una versión\nrecién lanzada es fácil. Desde tu shell, ejecuta el siguiente script de\nactualización:\n\n```console\n$ rustup update\n```\n\nPara desinstalar Rust y `rustup`, ejecuta el siguiente script de desinstalación\ndesde tu shell:\n\n```console\n$ rustup self uninstall\n```\n\n### Documentación local\n\nLa instalación de Rust también incluye una copia local de la documentación para\nque puedas leerla sin conexión. Ejecuta `rustup doc` para abrir la documentación\nlocal en tu navegador.\n\nEn cualquier momento en que se proporcione un tipo o una función de la biblioteca\nestándar y no estés seguro de lo que hace o cómo usarlo, usa la documentación de\nla interfaz de programación de aplicaciones (API) para averiguarlo.\n\n[otherinstall]: https://forge.rust-lang.org/infra/other-installation-methods.html\n[install]: https://www.rust-lang.org/tools/install\n[msvc]: https://rust-lang.github.io/rustup/installation/windows-msvc.html\n[community]: https://www.rust-lang.org/community\n[visualstudio]: https://visualstudio.microsoft.com/downloads/\n\n\n## Hello World\n\n\nAhora que has instalado Rust, es hora de escribir tu primer programa en Rust.\nEs tradicional cuando se aprende un nuevo lenguaje escribir un pequeño programa\nque imprima el texto `¡Hola, mundo!` en la pantalla.\n\n\n\n## Instalar Cargo\n\nCargo es el sistema de compilación y administrador de paquetes de Rust. La\nmayoría de los Rustaceans usan esta herramienta para administrar sus proyectos\nRust porque Cargo maneja muchas tareas para ti, como compilar tu código,\ndescargar las bibliotecas de las que depende tu código y compilar esas\nbibliotecas. (Llamamos *dependencias* a las bibliotecas de las que depende tu\ncódigo).\n\nLos programas Rust más simples, como el que hemos escrito hasta ahora, no\ntienen dependencias. Si hubiéramos construido el proyecto “¡Hola, mundo!” con\nCargo, sólo usaría la parte de Cargo que maneja la compilación de tu código. A\nmedida que escribas programas Rust más complejos, agregarás dependencias, y si\ncomienzas un proyecto usando Cargo, agregar dependencias será mucho más fácil\nde hacer.\n\nDebido a que la gran mayoría de los proyectos Rust usan Cargo, el resto de este\nlibro asume que también estás usando Cargo. Cargo viene instalado con Rust si\nusaste los instaladores oficiales que se discuten en la sección\n[“Installation”][installation]<!-- ignore -->. Si instalaste Rust a través de\nalgunos otros medios, verifica si Cargo está instalado ingresando lo siguiente\nen tu terminal:\n\n```console\n$ cargo --version\n```\n\nSi ves un número de versión, ¡lo tienes! Si ves un error, como `command not found`,\nconsulta la documentación de tu método de instalación para determinar cómo\ninstalar Cargo por separado.\n\n### Creación de un proyecto con Cargo\n\nVamos a crear un nuevo proyecto usando Cargo y ver cómo difiere de nuestro\nproyecto original “¡Hola, mundo!”. Navega de vuelta a tu directorio\n*proyectos* (o dondequiera que hayas decidido almacenar tu código). Luego, en\ncualquier sistema operativo, ejecuta lo siguiente:\n\n```console\n$ cargo new hello_cargo\n$ cd hello_cargo\n```\n\nEl primer comando crea un nuevo directorio y proyecto llamado *hello_cargo*.\nHemos nombrado a nuestro proyecto *hello_cargo*, y Cargo crea sus archivos en\nun directorio con el mismo nombre.\n\nVe al directorio *hello_cargo* y lista los archivos. Verás que Cargo ha\ngenerado dos archivos y un directorio para nosotros: un archivo *Cargo.toml* y\nun directorio *src* con un archivo *main.rs* dentro.\n\nTambién ha inicializado un nuevo repositorio Git junto con un archivo\n*.gitignore*. Los archivos Git no se generarán si ejecutas `cargo new` dentro\nde un repositorio Git existente; puedes anular este comportamiento usando\n`cargo new --vcs=git`.\n\n> Nota: Git es un sistema de control de versiones común. Puedes cambiar `cargo\n> new` para usar un sistema de control de versiones diferente o ningún sistema\n> de control de versiones usando la bandera `--vcs`. Ejecuta `cargo new --help`\n> para ver las opciones disponibles.\n\nAbre *Cargo.toml* en tu editor de texto de elección. Debería verse similar al\ncódigo del Listado 1-2.\n\n<Listing number=\"1-2\" file-name=\"Cargo.toml\" caption=\"Contenido de *Cargo.toml* generado por `cargo new`\">\n\n```toml\n[package]\nname = \"hello_cargo\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n\n[dependencies]\n```\n\n</Listing>\n\nEste archivo está en el formato [*TOML*][toml]<!-- ignore --> (*Tom’s Obvious,\nMinimal Language*), que es el formato de configuración de Cargo.\n\nLa primera línea, `[package]`, es un encabezado de sección que indica que las\nsiguientes declaraciones están configurando un paquete. A medida que agreguemos\nmás información a este archivo, agregaremos otras secciones.\n\nLas próximas tres líneas establecen la información de configuración que Cargo\nnecesita para compilar tu programa: el nombre, la versión y la edición de Rust\nque se usará. Hablaremos sobre la entrada `edition` en [Apéndice E][appendix-e]\n<!-- ignore -->.\n\nLa última línea, `[dependencies]`, es el comienzo de una sección para que\nenumere cualquier dependencia de tu proyecto. En Rust, los paquetes de código\nse denominan *crates*. No necesitaremos otros crates para este proyecto, pero\nlo haremos en el primer proyecto del Capítulo 2, por lo que usaremos esta\nsección de dependencias hasta entonces.\n\nAhora abre *src/main.rs* y echa un vistazo:\n\n<span class=\"filename\">Nombre de archivo: src/main.rs</span>\n\n```rust\nfn main() {\n    println!(\"Hello, world!\");\n}\n```\n\n¡Cargo ha generado un programa “Hello, world!”/“¡Hola, mundo!” para ti, \n¡igual que el que escribimos enl Listado 1-1! Hasta ahora, las diferencias \nentre nuestro proyecto y el proyecto generado por Cargo son que Cargo \ncolocó el código en el directorio *src* y tenemos un archivo de \nconfiguración *Cargo.toml* en el directorio superior.\n\nCargo espera que tus archivos de origen vivan dentro del directorio *src*. El\ndirectorio del proyecto de nivel superior es solo para archivos README, \ninformación de licencia, archivos de configuración y cualquier otra cosa \nque no esté relacionada con tu código. Usar Cargo te ayuda a organizar \ntus proyectos. Hay un lugar para todo, y todo está en su lugar.\n\nSi comenzaste un proyecto que no usa Cargo, como hicimos con el proyecto\n“¡Hola, mundo!”, puedes convertirlo en un proyecto que sí use Cargo. Mueve el\ncódigo del proyecto al directorio *src* y crea un archivo *Cargo.toml*\nadecuado.\n\n### Construir y ejecutar un proyecto de Cargo\n\nAhora veamos qué es diferente cuando construimos y ejecutamos el programa\n“¡Hola, mundo!” con Cargo. ¡Desde tu directorio *hello_cargo*, construye tu\nproyecto ingresando el siguiente comando:\n\n```console\n$ cargo build\n   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)\n    Finished dev [unoptimized + debuginfo] target(s) in 2.85 secs\n```\n\nEste comando crea un archivo ejecutable en *target/debug/hello_cargo* (o\n*target\\debug\\hello_cargo.exe* en Windows) en lugar de en tu directorio\nactual. Debido a que la compilación predeterminada es una compilación de\ndepuración, Cargo coloca el binario en un directorio llamado *debug*. Puedes\nllamar al ejecutable con este comando:\n\n```console\n$ ./target/debug/hello_cargo # o .\\target\\debug\\hello_cargo.exe en Windows\nHello, world!\n```\n\nSi todo va bien, `Hello, world!` debería imprimirse en la terminal. Ejecutar\n`cargo build` por primera vez también hace que Cargo cree un nuevo archivo en\nel nivel superior: *Cargo.lock*. Este archivo rastrea las versiones exactas de\nlas dependencias de tu proyecto. Este proyecto no tiene dependencias, por lo\nque el archivo es un poco escaso. Nunca necesitarás cambiar este archivo\nmanualmente; Cargo administra su contenido para ti.\n\nAcabamos de construir un proyecto con `cargo build` y ejecutarlo con\n`./target/debug/hello_cargo`, pero también podemos usar `cargo run` para\ncompilar el código y luego llamar al ejecutable resultante en un solo\ncomando:\n\n```console\n$ cargo run\n    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs\n     Running `target/debug/hello_cargo`\nHello, world!\n```\n\nUsar `cargo run` es más conveniente que tener que recordar ejecutar `cargo\nbuild` y luego usar la ruta completa al binario, por lo que la mayoría de los\ndesarrolladores usan `cargo run`.\n\nTen en cuenta que esta vez no vimos salida que indicara que Cargo estaba\ncompilando `hello_cargo`. Cargo supo que los archivos no habían cambiado, por\nlo que no volvió a construir, sino que solo ejecutó el binario. Si hubieras\nmodificado tu código fuente, Cargo habría reconstruido el proyecto antes de\nejecutarlo, y habrías visto esta salida:\n\n```console\n$ cargo run\n   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.33 secs\n     Running `target/debug/hello_cargo`\nHello, world!\n```\n\nCargo también proporciona un comando llamado `cargo check`. Este comando\ncomprueba rápidamente tu código para asegurarse de que compila, pero no\nproduce un ejecutable:\n\n```console\n$ cargo check\n   Checking hello_cargo v0.1.0 (file:///projects/hello_cargo)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.32 secs\n```\n\n¿Por qué no querrías un ejecutable? A menudo, `cargo check` es mucho más rápido\nque `cargo build` porque omite el paso de producir un ejecutable. Si estás\nverificando continuamente tu trabajo mientras escribes el código, usar\n`cargo check` acelerará el proceso de informarte si tu proyecto todavía aún está\ncompilando. ¡Por lo tanto, muchos Rustaceans ejecutan `cargo check`\nperiódicamente mientras escriben su programa para asegurarse de que compila!\nLuego ejecutan `cargo build` cuando están listos para usar el ejecutable.\n\nResumamos lo que hemos aprendido hasta ahora sobre Cargo:\n\n* Podemos crear un proyecto usando `cargo new`.\n* Podemos construir un proyecto usando `cargo build`.\n* Podemos construir y ejecutar un proyecto en un solo paso usando `cargo run`.\n* Podemos construir un proyecto sin producir un binario para verificar errores\n  usando `cargo check`.\n* En lugar de guardar el resultado de la compilación en el mismo directorio que\n  nuestro código, Cargo lo almacena en el directorio *target/debug*.\n\nUna ventaja adicional de usar Cargo es que los comandos son los mismos sin\nimportar en qué sistema operativo estés trabajando. Por lo tanto, en este\npunto, ya no proporcionaremos instrucciones específicas para Linux y macOS\nversus Windows.\n\n### Construyendo una versión de lanzamiento\n\nCuando tu proyecto finalmente esté listo para su lanzamiento, puedes usar `cargo\nbuild --release` para compilarlo con optimizaciones. Este comando creará un\nejecutable en *target/release* en lugar de *target/debug*. Las optimizaciones\nhacen que tu código Rust se ejecute más rápido, pero al activarlos se alarga el\ntiempo que tarda tu programa en compilarse. Es por eso que hay dos perfiles\ndiferentes: uno para el desarrollo, cuando deseas reconstruir rápidamente y\ncon frecuencia, y otro para construir el programa final que le darás al usuario,\nque no se reconstruirá repetidamente y que se ejecutará lo más rápido posible.\nSi estás midiendo el tiempo de ejecución de tu código, asegúrate de ejecutar\n`cargo build --release` y realizar la prueba de rendimiento con el ejecutable\nen *target/release*.\n\n### Cargo como convención\n\nCon proyectos simples, Cargo no proporciona mucho valor por sobre sólo usar\n`rustc`, pero demostrará su valor a medida que tus programas se vuelvan más\nintrincados. Una vez que los programas crecen a múltiples archivos o necesitan\nuna dependencia, es mucho más fácil dejar que Cargo coordine la construcción.\n\nAunque el proyecto `hello_cargo` es simple, ahora usas muchas de las herramientas\nreales que usarás en el resto de tu carrera en Rust. De hecho, para trabajar en\ncualquier proyecto existente, puedes usar los siguientes comandos para verificar\nel código usando Git, cambiar al directorio del proyecto y construir:\n\n\n```console\n$ git clone example.org/someproject\n$ cd someproject\n$ cargo build\n```\n\nPara obtener más información sobre Cargo, consulta [su documentación][cargo].\n\n[toml]: https://toml.io\n[cargo]: https://doc.rust-lang.org/cargo/\n\n\n## Extensiones para VS Code\n\n\n\n\n\nPuede encontrar e instalar la extensión rust-analyzer desde VS Code a través de la vista Extensiones (⇧⌘X) y buscando `rust-analyzer`. Debe instalar la versión de lanzamiento.\n\n![Extensión para Visual Studio Code llamada [rust-analyzer](https://code.visualstudio.com/docs/languages/rust)](images/Rust with VS Code.png)\n\n\nPuedes consultar la documentación de la extensión en [https://rust-analyzer.github.io](https://rust-analyzer.github.io).\n\n\nhttps://www.youtube.com/watch?v=Vde3-UUZAvU\n\n\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":false,"cache":null,"freeze":false,"echo":true,"output":true,"warning":false,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"markdown"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"center","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","html-math-method":"katex","css":["styles/style.css"],"highlight-style":"arrow","output-file":"install.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.4.554","bibliography":["references.bib"],"editor":"source","always_allow_html":true,"_quarto-vars":{"version":1,"email":{"author":"<denis.berroeta@uai.cl>"},"profesor":{"name":"[Denis Berroeta](https://cit.uai.cl/denis-berroeta/)","cargo":"Coordinador de Investigación, Centro de Inteligencia Territorial - UAI","email":"<denis.berroeta@uai.cl>"},"engine":{"jupyter":"[Jupyter](https://jupyter.org)","knitr":"[Knitr](<https://yihui.name/knitr>)","R":"[R Project](https://www.r-project.org)","python":"[Python](https://docs.python.org/es/3/tutorial/)"},"software":{"rstudio":"[RStudio](https://posit.co/products/open-source/rstudio/)"},"library":{"sf":"[Simple Features for R](https://r-spatial.github.io/sf/articles/sf1.html)","dplyr":"[dplyr](https://dplyr.tidyverse.org)","purrr":"[purrr](https://purrr.tidyverse.org)","mapview":"[mapview](https://r-spatial.github.io/mapview/)","lubridate":"[lubridate](https://lubridate.tidyverse.org)","tidyr":"[tidyr](https://tidyr.tidyverse.org)","plotly":"[plotly](https://plotly.com/r/)","ggplot":"[ggplot2](https://ggplot2.tidyverse.org/)"},"organization":{"ine":"[Instituto Nacional de Estadísticas](https://www.ine.gob.cl)","cran":"[CRAN (Comprehensive R Archive Network)](https://cran.r-project.org/)","bioconductor":"[Bioconductor](https://www.bioconductor.org/)","github":"[Github](https://github.com/)","rforge":"[R-Forge](https://r-forge.r-project.org/)"}},"theme":"cosmo","fig-cap-location":"margin","tab-cap-location":"left","mailto":"denis.berroeta@uai.cl","code-block-bg":true,"code-block-border-left":"#31BAE9","title":"Instalación"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}