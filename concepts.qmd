# Conceptos Básicos

Este capítulo cubre conceptos que aparecen en casi todos los lenguajes de programación y cómo funcionan en Rust. Muchos lenguajes de programación tienen mucho en común en su núcleo. Ninguno de los conceptos presentados en este capítulo son únicos de Rust, pero los discutiremos en el contexto de Rust y explicaremos las convenciones alrededor de su uso.

Específicamente, aprenderás sobre variables, tipos básicos, funciones, comentarios y flujo de control. Estas bases estarán en todos los programas de Rust, y aprenderlas temprano te dará un núcleo fuerte para comenzar.

## Variables y Mutabilidad

En Rust, las variables son inmutables por defecto, lo que promueve la seguridad y la concurrencia. Esto significa que una vez que se asigna un valor a una variable, no puede ser cambiado. Sin embargo, Rust permite optar por variables mutables si es necesario.

Por ejemplo, el siguiente código da un error porque intenta reasignar un valor a la variable x sin hacerla mutable:

``` rust

fn main() {
    let x = 5;
    println!("El valor de x es: {x}");
    x = 6; // Error: no se puede asignar dos veces a una variable inmutable.
}
```

Este error es útil porque garantiza que no modifiquemos accidentalmente variables que deben permanecer inmutables, lo que puede causar errores difíciles de detectar.

Si necesitas cambiar el valor de una variable, puedes hacerla mutable usando `mut`:

``` rust

fn main() {
    let mut x = 5;
    println!("El valor de x es: {x}");
    x = 6;
    println!("El nuevo valor de x es: {x}");
}

```

Con `mut`, el valor de `x` puede cambiar de 5 a 6. La mutabilidad es útil en muchos casos, pero usar variables inmutables puede ayudar a evitar errores y hacer que tu código sea más fácil de entender.

## Tipos de datos básicos

Rust es un lenguaje fuertemente tipado, lo que significa que cada valor debe tener un tipo específico. Estos tipos se dividen principalmente en dos categorías: tipos escalares y tipos compuestos. En esta sección, nos centraremos en los tipos escalares, que representan un valor único.

### Tipos Escalares

Los tipos escalares incluyen enteros, números de coma flotante, caracteres y booleanos. A continuación, se presenta una tabla con los principales tipos de datos y ejemplos de sus valores literales:

| Tipo | Sintaxis | Ejemplos |
|--------------------|------------------------------|----------------------|
| Enteros con signo | i8, i16, i32, i64, i128, isize | -10, 0, 1_000, 123_i64 |
| Enteros sin signo | u8, u16, u32, u64, u128, usize | 0, 123, 10_u16 |
| Números de coma flotante | f32, f64 | 3.14, -10.0e20, 2_f32 |
| Valores escalares Unicode | char | 'a', 'α', '∞' |
| Booleanos | bool | true, false |

**Ancho de los Tipos**

Cada tipo tiene un tamaño específico en memoria:

-   `iN`, `uN`, y `fN` tienen un ancho de N bits.
-   `isize` y `usize` tienen el ancho de un puntero, lo que depende de la arquitectura del sistema (generalmente 32 o 64 bits).
-   `char` tiene un tamaño de 32 bits, lo que permite representar cualquier carácter Unicode.
-   `bool` ocupa 8 bits de espacio en memoria.

Ejemplo de Uso

Podemos ver cómo se utilizan estos tipos de datos en un programa simple:

``` rust
fn main() {
    let entero_con_signo: i32 = -500;
    let entero_sin_signo: u32 = 300;
    let flotante: f64 = 3.1415;
    let caracter: char = '∞';
    let booleano: bool = true;
    
    println!("Entero con signo: {}", entero_con_signo);
    println!("Entero sin signo: {}", entero_sin_signo);
    println!("Flotante: {}", flotante);
    println!("Carácter: {}", caracter);
    println!("Booleano: {}", booleano);
}
```

Este ejemplo muestra cómo declarar y utilizar los diferentes tipos de datos en Rust, cada uno con su correspondiente tipo y valor literal.

## Control de Flujos

En Rust, el control de flujos permite dirigir la ejecución del programa basándose en condiciones y repeticiones. Rust ofrece varias estructuras para controlar el flujo de la ejecución del código, como if para condiciones y bucles para repetir bloques de código.

Aquí tienes una tabla con las operaciones lógicas y su sintaxis en Rust, qué se utilizan en control de flujos:

| **Operación** | **Símbolo** | **Descripción** | **Ejemplo** |
|---------------|---------------|----------------------------|---------------|
| **AND lógico** | `&&` | Verdadero si ambas expresiones son verdaderas | `true && false` (devuelve `false`) |
| **OR lógico** | `||` | Verdadero si al menos una expresión es verdadera | `true || false` (devuelve `true`) |
| **NOT lógico** | `!` | Invierte el valor de verdad de una expresión | `!true` (devuelve `false`) |
| **Igualdad** | `==` | Verdadero si ambas expresiones son iguales | `5 == 5` (devuelve `true`) |
| **Desigualdad** | `!=` | Verdadero si ambas expresiones no son iguales | `5 != 6` (devuelve `true`) |
| **Mayor que** | `>` | Verdadero si la primera expresión es mayor que la segunda | `6 > 3` (devuelve `true`) |
| **Menor que** | `<` | Verdadero si la primera expresión es menor que la segunda | `3 < 5` (devuelve `true`) |
| **Mayor o igual que** | `>=` | Verdadero si la primera expresión es mayor o igual a la segunda | `5 >= 5` (devuelve `true`) |
| **Menor o igual que** | `<=` | Verdadero si la primera expresión es menor o igual a la segunda | `3 <= 4` (devuelve `true`) |

### Expresión if

En Rust, la expresión if evalúa una condición booleana y ejecuta un bloque de código dependiendo de si la condición es verdadera (true) o falsa (false). A diferencia de otros lenguajes, if en Rust es una expresión, lo que significa que puede devolver un valor.

``` rust
fn main() {
    let numero = 5;

    if numero > 3 {
        println!("El número es mayor que 3.");
    } else {
        println!("El número es 3 o menor.");
    }
}
```

También se puede usar la expresión if para asignar valores:

``` rust
let condicion = true;
let numero = if condicion { 5 } else { 6 };
```

Es importante recordar que las ramas del if deben devolver el mismo tipo.

### Bucles

Rust proporciona tres tipos de bucles: `loop`, `while`, y `for`.

`loop`

:   Ejecuta un bloque de código indefinidamente hasta que se detenga explícitamente con una instrucción break.

``` rust
fn main() {
    let mut contador = 0;

    loop {
        contador += 1;
        println!("Contador: {contador}");

        if contador == 5 {
            break;  // Detiene el bucle cuando contador es 5
        }
    }
}
```

`while`

:   Ejecuta un bloque de código mientras una condición booleana sea verdadera.

``` rust
fn main() {
    let mut numero = 3;

    while numero != 0 {
        println!("{numero}");
        numero -= 1;
    }
}
```

`for`

:   Recorre elementos de una colección o un rango.

``` rust
fn main() {
    for numero in 1..4 {
        println!("{numero}");
    }
}
```

### break y continue

`break`: Termina el bucle inmediatamente.

`continue`: Salta al siguiente ciclo del bucle sin ejecutar el resto del bloque actual.

Ejemplo combinando ambos:

``` rust
fn main() {
    for numero in 1..10 {
        if numero == 5 {
            continue;  // Salta cuando número es 5
        } else if numero == 8 {
            break;  // Termina el bucle cuando número es 8
        }
        println!("Número: {numero}");
    }
}
```

## Bloques y Ámbitos

En Rust, un bloque es un conjunto de declaraciones y expresiones encerradas entre llaves `{}`, que define un ámbito o scope. Los bloques permiten organizar el código y controlar la visibilidad y la duración de las variables.

### Bloques

Un bloque es simplemente un conjunto de instrucciones encerradas entre `{}`. Puedes usarlos en funciones, if, while, for y otras estructuras de control de flujo. Por ejemplo:

``` rust

fn main() {
    let x = 5;
    let y = {
        let x = 3;
        x + 1  // Este bloque devuelve 4
    };
    
    println!("El valor de y es: {y}");  // Imprime 4
}
```

En este caso, el valor de y se asigna al resultado del bloque {}, que devuelve 4. Dentro del bloque, el valor de x es 3, pero fuera del bloque sigue siendo 5. Esto demuestra cómo los bloques crean un nuevo ámbito.

### Ámbitos (Scope)

Cada variable tiene un ámbito, que es el área del código donde la variable está visible y disponible para su uso. El ámbito comienza cuando se declara la variable y termina cuando el bloque que contiene la variable finaliza.

``` rust
fn main() {
    let x = 5; // El ámbito de `x` comienza aquí

    {
        let y = 10;  // El ámbito de `y` comienza aquí
        println!("Dentro del bloque: x = {x}, y = {y}");
    }  // El ámbito de `y` termina aquí

    // Aquí, `y` ya no es accesible, pero `x` aún lo es
    println!("Fuera del bloque: x = {x}");
}
```

En el ejemplo anterior, y solo existe dentro del bloque interno. Intentar acceder a y fuera de ese bloque resultaría en un error, ya que su ámbito ha terminado. Sin embargo, x sigue accesible porque fue declarada en un ámbito más amplio (el bloque principal).

### Sombra de Variables (Variable Shadowing)

Rust permite sombras de variables, lo que significa que puedes declarar una nueva variable con el mismo nombre en un nuevo bloque, y esta nueva variable “sombrea” la anterior.

``` rust
fn main() {
    let x = 5;

    {
        let x = x * 2;  // Esta nueva `x` sombrea la anterior
        println!("El valor de x dentro del bloque es: {x}");  // Imprime 10
    }

    println!("El valor de x fuera del bloque es: {x}");  // Imprime 5
}
```

La variable x dentro del bloque es independiente de la x fuera del bloque, y la versión de x fuera del bloque no se ve afectada por los cambios realizados dentro del bloque interno.

### Duración de Vida (Lifetimes)

El ámbito también está relacionado con el concepto de duración de vida en Rust, que se refiere a cuánto tiempo vive una referencia o variable. Aunque no se necesita usar anotaciones de tiempo de vida en muchos casos, se volverán importantes cuando trabajes con referencias y prestamistas en bloques más complejos.

## Funciones

En Rust, las funciones son un componente clave para organizar y reutilizar código. Permiten dividir el programa en partes más pequeñas y manejables. Toda función en Rust debe estar declarada con el tipo de datos que espera recibir (parámetros) y el tipo de dato que devolverá (si corresponde).

Definición de Funciones

La sintaxis básica para definir una función en Rust es la siguiente:

``` rust
fn nombre_de_la_funcion(parámetros: tipo) -> tipo_de_retorno {
    // cuerpo de la función
}
```

-   **fn**: Indica que estamos declarando una función.
-   **nombre_de_la_funcion**: El nombre de la función, que sigue las convenciones de estilo `snake_case`.
-   **parámetros**: Una lista de parámetros opcionales que la función toma como entrada.
-   **tipo_de_retorno**: El tipo de valor que la función devolverá (si no devuelve nada, se omite).
-   El **cuerpo de la función** es donde se especifica el comportamiento.


Ejemplo Simple de Función

Aquí tienes un ejemplo de una función que toma dos números enteros como parámetros y devuelve su suma:

```rust
fn sumar(a: i32, b: i32) -> i32 {
    a + b  // El valor de retorno es la última expresión
}

fn main() {
    let resultado = sumar(5, 3);
    println!("El resultado es: {resultado}");
}
```

En este ejemplo:

- La función devuelve un valor de tipo `i32`, que es la suma de a y b.
- La última expresión dentro de una función se devuelve automáticamente si no se termina con un punto y coma.

**Parámetros**

Los parámetros se definen dentro de los paréntesis cuando declaras una función, especificando tanto el nombre como el tipo de dato. Puedes pasar múltiples parámetros:

```rust
fn multiplicar(x: i32, y: i32) -> i32 {
    x * y
}
```
Rust requiere que especifiques el tipo de todos los parámetros de la función.

**Valores de Retorno**

Una función puede devolver un valor usando una expresión o una instrucción `return` opcional. En Rust, la última expresión en el cuerpo de la función sin punto y coma se devuelve automáticamente.

```rust
fn cuadrado(x: i32) -> i32 {
    return x * x;  // También puedes usar `return` explícitamente
}
```

Si no deseas que la función devuelva un valor, puedes omitir la flecha `->` y el tipo de retorno, lo que significa que la función devolverá la unidad `()`:

```rust
fn saludar() {
    println!("Hola, mundo!");
}
```


**Funciones con Referencias**

Rust también permite pasar referencias a las funciones, lo que es útil cuando no deseas transferir la propiedad de un valor. Las referencias permiten que la función lea el valor sin tomar posesión de él:


```rust
fn longitud(texto: &String) -> usize {
    texto.len()
}
```


En este ejemplo, &String indica que la función toma una referencia al valor en lugar de transferir su propiedad.

**Funciones Anidadas**

Puedes definir funciones dentro de otras funciones en Rust, lo que se llama funciones anidadas. Esto puede ser útil para encapsular lógica específica dentro de un contexto limitado:

```rust
fn main() {
    fn interna() {
        println!("Esta es una función anidada");
    }

    interna();  // Llamando a la función anidada
}
```

**Funciones con Tipos Genéricos**

Rust permite que las funciones acepten tipos genéricos, lo que hace que las funciones sean más flexibles y reutilizables. Por ejemplo:


```rust
fn imprimir_dos_veces<T: std::fmt::Debug>(x: T) {
    println!("{:?} {:?}", x, x);
}
```

Aquí, `T` es un tipo genérico, y `std::fmt::Debug` es un trait que indica que el tipo debe poder imprimirse con `{:?}`.

## Macros

En Rust, las macros son una poderosa característica que permite escribir código que genera otros fragmentos de código durante la compilación. Las macros permiten realizar tareas repetitivas, trabajar con estructuras complejas y proporcionar una mayor flexibilidad que las funciones estándar.

A diferencia de las funciones, las macros pueden aceptar un número variable de argumentos y no están limitadas a trabajar solo con tipos específicos. Además, las macros en Rust se expanden antes de que el código sea compilado, lo que las hace útiles para metaprogramación.

**Macros vs Funciones**

Aunque las macros y las funciones pueden parecer similares, tienen algunas diferencias clave:

- Funciones: Se ejecutan en tiempo de ejecución y trabajan con parámetros de tipos específicos.

- Macros: Se expanden en código en tiempo de compilación, lo que permite generar fragmentos de código personalizados.

Por ejemplo, una función recibe un número fijo de argumentos de un tipo determinado, mientras que una macro puede manejar un número variable de argumentos de cualquier tipo. La exclamación `!` es lo que distingue a las macros de las funciones.


**Macros Más Comunes**

Rust incluye varias macros predefinidas que son ampliamente utilizadas. Algunas de las más comunes son:

`println!`: Imprime un mensaje formateado en la consola.

```rust
fn main() {
    println!("Hola, mundo!");
}
```

`vec!`: Crea un vector con elementos iniciales.

```rust
fn main() {
    let v = vec![1, 2, 3];
    println!("{:?}", v);
}

```

La macro vec! permite crear un vector con varios elementos sin tener que declarar su tipo explícitamente.


**Defincición de Macros**

Las macros se definen usando el macro sistema macro_rules!. A continuación, un ejemplo básico de cómo definir una macro que acepta dos expresiones y las imprime:

```rust
macro_rules! saludar {
    ($nombre:expr) => {
        println!("Hola, {}!", $nombre);
    };
}

fn main() {
    saludar!("Rust");
}
```

Aquí, saludar! es la macro que toma un único argumento de tipo expresión ($nombre:expr) y genera una llamada a println! con ese argumento. El uso de $nombre:expr es parte de la sintaxis de las macros en Rust, que permite definir patrones y expandir el código.

**Macros con Múltiples Patrones**

Las macros pueden manejar múltiples patrones de entrada, lo que les permite comportarse de manera diferente dependiendo de cuántos o qué tipos de argumentos se les pasen:


```rust
macro_rules! sumar {
    ($a:expr, $b:expr) => {
        println!("La suma es: {}", $a + $b);
    };
    ($a:expr, $b:expr, $c:expr) => {
        println!("La suma es: {}", $a + $b + $c);
    };
}

fn main() {
    sumar!(2, 3);         // La suma es: 5
    sumar!(2, 3, 4);      // La suma es: 9
}

```

En este ejemplo, la macro sumar! puede aceptar dos o tres argumentos y ejecutará una acción diferente según el número de parámetros proporcionados.


**Macros Recursivas**

Rust también permite la creación de macros recursivas, que pueden llamarse a sí mismas hasta cumplir una condición. Esto es útil cuando necesitas generar estructuras de código repetitivas.

```rust
macro_rules! contador {
    ($primero:expr) => {
        println!("{}", $primero);
    };
    ($primero:expr, $($resto:expr),*) => {
        println!("{}", $primero);
        contador!($($resto),*);
    };
}

fn main() {
    contador!(1, 2, 3, 4, 5);
}
```

Este ejemplo imprime cada número en una nueva línea, y la macro se llama recursivamente hasta que solo queda un argumento.

**Cuándo Usar Macros**

Las macros son útiles cuando:

* Necesitas generar código repetitivo.
* Quieres aceptar una cantidad variable de argumentos o tipos de entrada.
* Quieres realizar optimizaciones en tiempo de compilación.

Sin embargo, las macros deben usarse con cuidado, ya que pueden hacer que el código sea más difícil de leer y depurar debido a su naturaleza de metaprogramación. Se recomienda usarlas solo cuando las funciones no sean suficientes para el caso en cuestión.



## Tipos Compuestos

Tuplas

:   Agrupan múltiples valores de diferentes tipos en una única entidad. La longitud de una tupla es fija, y los tipos de los elementos pueden variar.

Ejemplo de tupla:

``` rust

let tupla: (i32, f64, char) = (500, 6.4, 'a');
let (x, y, z) = tupla;  // Destructuring para acceder a los valores
```

Arreglos (Arrays)

:   Los arreglos contienen múltiples valores del mismo tipo. A diferencia de los vectores, los arreglos tienen una longitud fija que no puede cambiar.

Ejemplo de arreglo:

``` rust

let arreglo: [i32; 5] = [1, 2, 3, 4, 5];  // Un arreglo de 5 enteros
let primer_elemento = arreglo[0];  // Acceder al primer elemento
```

Aquí tienes una tabla para los tipos compuestos:

| Tipo | Sintaxis | Ejemplos |
|---------------|-----------------------|----------------------------------|
| Tuplas | (T1, T2, T3, ...) | (500, 6.4, 'a') |
| Arreglos | \[T; N\] (T es tipo, N es tamaño) | \[1, 2, 3, 4, 5\], \[3.14; 3\] (inicializa con 3.14 tres veces) |



## Iteradores

Un iterador es una estructura que permite recorrer una secuencia de elementos, como un arreglo, una lista o cualquier colección de datos, uno a la vez. En Rust, los iteradores son una herramienta poderosa y flexible, que se pueden usar para manipular y procesar colecciones de manera eficiente y expresiva.

**¿Qué es un Iterador?**

En Rust, un iterador es cualquier tipo que implemente el trait Iterator. Los iteradores proporcionan dos funciones principales:

next
: Proporciona acceso al siguiente elemento en la secuencia. Cuando no hay más elementos, devuelve None.

Métodos de adaptación
: Métodos como map, filter, y collect que permiten transformar los iteradores.

Ejemplo básico de uso de next:

```rust
fn main() {
    let numeros = vec![1, 2, 3];
    let mut iter = numeros.iter();

    println!("{:?}", iter.next());  // Imprime Some(1)
    println!("{:?}", iter.next());  // Imprime Some(2)
    println!("{:?}", iter.next());  // Imprime Some(3)
    println!("{:?}", iter.next());  // Imprime None
}
```

**Crear un Iterador**

La mayoría de las colecciones en Rust pueden convertirse en iteradores usando el método iter. Para iterar sobre un vector o un array:

```rust
fn main() {
    let numeros = vec![1, 2, 3, 4, 5];
    
    for numero in numeros.iter() {
        println!("{}", numero);
    }
}
```

En este caso, `numeros.iter()` devuelve un iterador sobre el vector numeros. El ciclo for se encarga de llamar a `next` por nosotros y obtiene cada elemento en la secuencia.

**Métodos de Adaptación de Iteradores**

Rust proporciona varios métodos de iterador que permiten transformar, filtrar y combinar secuencias de manera eficiente. Estos métodos no consumen el iterador, sino que devuelven un nuevo iterador, lo que permite encadenarlos de manera elegante.

Algunos de los métodos más comunes son:

`map`
: Aplica una función a cada elemento y devuelve un nuevo iterador con los resultados.

```rust
fn main() {
    let numeros = vec![1, 2, 3, 4];
    let cuadrados: Vec<i32> = numeros.iter().map(|x| x * x).collect();
    println!("{:?}", cuadrados);  // Imprime [1, 4, 9, 16]
}
```

`filter`
: Filtra elementos según una condición.

```rust
fn main() {
    let numeros = vec![1, 2, 3, 4, 5];
    let pares: Vec<i32> = numeros.iter().filter(|&&x| x % 2 == 0).collect();
    println!("{:?}", pares);  // Imprime [2, 4]
}
```

`collect`
: Convierte un iterador en una colección, como un `Vec`, un HashMap, entre otros.


```rust
fn main() {
    let numeros = vec![1, 2, 3, 4];
    let resultado: Vec<i32> = numeros.iter().map(|x| x + 1).collect();
    println!("{:?}", resultado);  // Imprime [2, 3, 4, 5]
}
```

`enumerate`
: Asigna un índice a cada elemento del iterador.

```rust
fn main() {
    let numeros = vec!["a", "b", "c"];
    for (i, letra) in numeros.iter().enumerate() {
        println!("Índice: {}, Letra: {}", i, letra);
    }
}
```


**Consumo de Iteradores**

Algunos métodos de iterador consumen el iterador, lo que significa que una vez que el método ha sido ejecutado, el iterador ya no puede ser utilizado. Algunos ejemplos de métodos que consumen iteradores son:

`sum`
: Calcula la suma de todos los elementos de un iterador numérico.
	
```rust
fn main() {
    let numeros = vec![1, 2, 3, 4];
    let suma: i32 = numeros.iter().sum();
    println!("La suma es: {}", suma);  // Imprime 10
}
```

`find`
: Busca el primer elemento que cumpla con una condición.

```rust
fn main() {
    let numeros = vec![1, 2, 3, 4];
    if let Some(num) = numeros.iter().find(|&&x| x == 3) {
        println!("Número encontrado: {}", num);  // Imprime 3
    }
}
```


**Iteradores Inmutables y Mutables**

Rust te permite crear tanto iteradores inmutables como iteradores mutables. Los iteradores inmutables (iter()) te permiten acceder a los elementos de una colección sin modificarla, mientras que los iteradores mutables (iter_mut()) te permiten modificar los elementos mientras los recorres.

```rust
fn main() {
    let mut numeros = vec![1, 2, 3, 4];

    for num in numeros.iter_mut() {
        *num += 1;
    }
    
    println!("{:?}", numeros);  // Imprime [2, 3, 4, 5]
}
```

**Creación de Iteradores Personalizados**

Además de usar los iteradores integrados, también puedes implementar el trait Iterator para crear tus propios iteradores personalizados. Esto te permite definir cómo deben comportarse tus estructuras de datos al ser iteradas.

```rust
struct Contador {
    actual: u32,
    limite: u32,
}

impl Contador {
    fn nuevo(limite: u32) -> Contador {
        Contador { actual: 0, limite }
    }
}

impl Iterator for Contador {
    type Item = u32;

    fn next(&mut self) -> Option<Self::Item> {
        if self.actual < self.limite {
            self.actual += 1;
            Some(self.actual)
        } else {
            None
        }
    }
}

fn main() {
    let mut contador = Contador::nuevo(5);

    while let Some(valor) = contador.next() {
        println!("{}", valor);
    }
}
```
En este ejemplo, se define un iterador personalizado Contador que genera una secuencia de números de 1 a limite.


## Closures

Un closure (o cierre) en Rust es una función anónima que puede capturar variables del entorno en el que se define. Los closures son muy flexibles y pueden aceptar parámetros, devolver valores y, a diferencia de las funciones normales, pueden capturar y utilizar variables que no se les pasan explícitamente.

Los closures se definen usando la siguiente sintaxis:

```rust
|parametros| expresión
```

Son comunes en Rust para trabajar con iteradores y otras operaciones funcionales, como map y filter.

**Definición Básica**

Aquí tienes un ejemplo básico de un closure que suma dos números:

```rust
fn main() {
    let suma = |a, b| a + b;
    println!("La suma es: {}", suma(2, 3));
}
```


En este ejemplo:

- `|a, b|` es la lista de parámetros del closure.
- `a + b` es la expresión que se ejecuta cuando se llama al closure.
- Se llama al closure con suma(2, 3), y el resultado es 5.

**Captura de Variables**

Una característica clave de los closures es su capacidad para capturar variables del entorno en el que fueron definidos. Pueden capturar variables por referencia, por préstamo mutable o por posesión, dependiendo de cómo se utilicen.

```rust
fn main() {
    let x = 4;
    let closure = |y| x + y;
    println!("Resultado: {}", closure(3));  // Imprime 7
}
```
En este caso, el closure closure captura la variable x del entorno y la utiliza en su cuerpo.

**Closures que Capturan por Referencia, Mutable y por Posesión**

Los closures pueden capturar variables de diferentes maneras:

Por referencia
: El closure accede a la variable sin tomar posesión de ella.

```rust
fn main() {
    let x = 5;
    let capturar_x = || println!("x: {}", x);  // Captura `x` por referencia
    capturar_x();
}
```


Por mutabilidad
: El closure puede modificar la variable.

```rust
fn main() {
    let mut x = 5;
    let mut modificar_x = || x += 1;  // Captura `x` por mutabilidad
    modificar_x();
    println!("x: {}", x);  // Imprime 6
}
```


Por posesión
: El closure toma posesión de la variable, lo que impide su uso fuera del closure.

```rust
fn main() {
    let x = String::from("Hola");
    let capturar_x = || {
        let _y = x;  // Captura `x` por posesión
    };
    capturar_x();
    // Aquí `x` ya no es accesible porque fue capturado por posesión
}
```

**Closures con Tipos y Anotaciones de Parámetros**

En la mayoría de los casos, Rust puede inferir los tipos de los parámetros de un closure, por lo que no es necesario especificarlos. Sin embargo, también puedes hacerlo explícitamente si lo deseas:

```rust
fn main() {
    let suma = |a: i32, b: i32| -> i32 { a + b };
    println!("La suma es: {}", suma(10, 5));
}
```
En este caso, hemos anotado los tipos de los parámetros (i32) y el tipo de retorno del closure (i32).


Closures y Funciones

A diferencia de las funciones, los closures pueden capturar variables del entorno. Sin embargo, los closures y las funciones comparten algunas similitudes. Los closures se pueden almacenar en variables, pasar como argumentos o devolver desde otras funciones, al igual que las funciones.

Los closures también pueden ser pasados como parámetros a funciones que esperan un trait como `Fn`, `FnMut`, o `FnOnce`

**Traits Fn, FnMut, y FnOnce**

Rust proporciona tres traits principales para closures, dependiendo de cómo el closure maneje las variables capturadas:

1.	Fn: El closure no modifica ni toma posesión de las variables que captura. Se llama múltiples veces sin efectos secundarios.
2.	FnMut: El closure puede modificar las variables que captura, pero no toma posesión de ellas. Se llama múltiples veces, pero puede tener efectos secundarios.
3.	FnOnce: El closure toma posesión de las variables que captura, por lo que solo puede ser llamado una vez.

Por ejemplo:


```rust
fn ejecutar_closure<F>(f: F) 
where
    F: Fn(i32) -> i32 
{
    println!("Resultado: {}", f(5));
}

fn main() {
    let closure = |x| x + 1;
    ejecutar_closure(closure);
}

```
Aquí, ejecutar_closure acepta un parámetro F que implementa el trait Fn, lo que permite pasarle closures que no modifican las variables capturadas.

**Closures como Retorno**

También puedes devolver un closure desde una función, utilizando el trait adecuado:

```rust
fn crear_closure() -> impl Fn(i32) -> i32 {
    |x| x + 1
}

fn main() {
    let mi_closure = crear_closure();
    println!("Resultado: {}", mi_closure(10));  // Imprime 11
}
```

Aquí, la función crear_closure devuelve un closure que toma un entero y devuelve ese entero incrementado en uno.

**Closures en Iteradores**

Los closures son ampliamente utilizados en operaciones con iteradores, como map, filter, fold, entre otros. Estos métodos aceptan closures para realizar operaciones sobre cada elemento de una colección.

Por ejemplo, el uso de un closure con map para elevar al cuadrado los números de un vector:

```rust
fn main() {
    let numeros = vec![1, 2, 3, 4];
    let cuadrados: Vec<i32> = numeros.iter().map(|x| x * x).collect();
    println!("{:?}", cuadrados);  // Imprime [1, 4, 9, 16]
}
```


## Manejo de errores

En Rust, el manejo de errores se divide en dos categorías principales: errores recuperables (gestionados con Result) y errores irrecuperables (gestionados con panic!).

Result: Errores Recuperables

El tipo Result es usado cuando una operación puede tener éxito o fallar. Tiene dos variantes:

- Ok(T): Representa un éxito y contiene un valor.
- Err(E): Representa un error y contiene información del mismo.

Ejemplo básico:

```rust
use std::fs::File;

fn main() {
    let archivo = File::open("archivo.txt");

    match archivo {
        Ok(_) => println!("Archivo abierto."),
        Err(e) => println!("Error: {}", e),
    }
}
```

También puedes usar el operador ? para simplificar el manejo de errores, propagando el error si ocurre:

```rust
fn leer_archivo() -> Result<String, std::io::Error> {
    let mut archivo = File::open("archivo.txt")?;
    let mut contenido = String::new();
    archivo.read_to_string(&mut contenido)?;
    Ok(contenido)
}
```

**Option: Valores Opcionales**

Option es usado para manejar valores que pueden estar presentes o no. Tiene dos variantes:

- Some(T): Representa un valor.
- None: Representa la ausencia de un valor.

Ejemplo:

```rust
fn dividir(dividendo: f64, divisor: f64) -> Option<f64> {
    if divisor == 0.0 {
        None
    } else {
        Some(dividendo / divisor)
    }
}
```

**panic!: Errores Irrecuperables**

Cuando ocurre un error grave del que el programa no puede recuperarse, se usa panic! para detener la ejecución:


```rust
fn main() {
    panic!("¡Error grave!");
}
```


