---
title: "Impl"
subtitle: "Implementaciones: Dando Vida a los Datos"
---


Hasta ahora hemos visto c贸mo estructurar datos con **Structs** y **Enums**. Sin embargo, por s铆 solos, son solo contenedores de datos pasivos. No "hacen" nada.

El bloque `impl` (implementaci贸n) es la herramienta que nos permite definir el **comportamiento** asociado a un tipo de dato. Es aqu铆 donde transformamos simples estructuras de datos en objetos con funcionalidad propia.

## Concepto Fundamental

###  Analog铆a: El Robot

Imagina un robot:

*   El **Struct** es el **Hardware**: La lista de piezas, sensores, ruedas y cables. Define *qu茅 tiene* el robot.
*   El **Impl** es el **Software**: El c贸digo que le dice c贸mo moverse, c贸mo leer los sensores y c贸mo reaccionar. Define *qu茅 puede hacer* el robot.

Sin el `impl`, el robot es solo un mont贸n de metal inm贸vil.

## Tipos de Funciones en un `impl`

Dentro de un bloque `impl`, podemos definir dos tipos de funciones:

### 1. M茅todos (Acciones)

Son funciones que act煤an sobre una instancia espec铆fica del struct. Siempre toman `self` (o `&self`, `&mut self`) como primer argumento. Representan lo que el objeto puede hacerse a s铆 mismo o con sus datos.

*Ejemplo:* "Edificio, enciende tus luces".

### 2. Funciones Asociadas (Utilidades/Constructores)
Son funciones relacionadas con el tipo, pero que no necesitan una instancia espec铆fica para funcionar. Se usan a menudo como "constructores" para crear nuevas instancias. No toman `self`.

*Ejemplo:* "Plano, crea un nuevo edificio".

---

## Ejemplo Pr谩ctico: Controlando un Drone

Siguiendo nuestra tem谩tica de ciudad y tecnolog铆a, usemos un **Drone** como ejemplo.

```rust
struct Drone {
    nombre: String,
    bateria: u8, // Porcentaje 0-100
    en_vuelo: bool,
}

// Aqu铆 empieza la "vida" del Drone
impl Drone {
    // FUNCIN ASOCIADA (Constructor)
    // No usa &self. Se llama como Drone::nuevo(...)
    fn nuevo(nombre: String) -> Drone {
        Drone {
            nombre,
            bateria: 100, // Empieza siempre lleno y en el suelo
            en_vuelo: false,
        }
    }

    // MTODO (Lee el estado)
    // Usa &self (lectura inmutable)
    fn describir(&self) {
        let estado = if self.en_vuelo { "Voplando" } else { "En tierra" };
        println!("Drone '{}': Bater铆a {}% - Estado: {}", self.nombre, self.bateria, estado);
    }

    // MTODO (Modifica el estado)
    // Usa &mut self (lectura y escritura)
    fn despegar(&mut self) {
        if self.bateria > 20 {
            self.en_vuelo = true;
            self.bateria -= 10; // Gasta bater铆a al despegar
            println!(" {} ha despegado.", self.nombre);
        } else {
            println!("锔 {} no tiene suficiente bater铆a para despegar.", self.nombre);
        }
    }
}

fn main() {
    // Usamos la funci贸n asociada para crear el dron
    let mut mi_drone = Drone::nuevo("Halc贸n 1".to_string());
    
    mi_drone.describir();
    mi_drone.despegar();
    mi_drone.describir();
}
```

## Comparaci贸n con R

Si vienes de R, especialmente de usar **S3**, notar谩s una diferencia clave en la organizaci贸n.

### En R (Estilo S3 Funcional)
En R, los datos y las funciones suelen estar separados. Defines la estructura (una lista) y luego funciones sueltas que operan sobre esa lista.

```r
# Definici贸n de datos
crear_drone <- function(nombre) {
  list(nombre = nombre, bateria = 100, en_vuelo = FALSE)
}

# Funciones sueltas
despegar_drone <- function(drone) {
  drone$en_vuelo <- TRUE
  return(drone)
}

# Uso
mi_drone <- crear_drone("Halc贸n 1")
mi_drone <- despegar_drone(mi_drone)
```

El problema en R a veces es saber: *驴Qu茅 funciones existen para este objeto?* Tienes que buscar en la documentaci贸n o adivinar el nombre.

### En Rust (`impl`)
Rust agrupa todas las funciones que pertenecen al `Drone` dentro del bloque `impl Drone`.

*   **Organizaci贸n**: Sabes exactamente d贸nde buscar el c贸digo relacionado con `Drone`.
*   **Autocompletado**: Los editores de c贸digo pueden mostrarte instant谩neamente qu茅 m茅todos est谩n disponibles en cuanto escribes un punto (`.`).
*   **Encapsulamiento**: Queda claro qu茅 l贸gica pertenece exclusivamente a este tipo de dato.

El bloque `impl` act煤a como el "hogar" de la l贸gica de tus datos.
